/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/22 21:33:51 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/11 20:45:36 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	free_lle(t_data *data)
{
	t_env *temp = NULL;

	while (data->env)
	{
		temp = data->env->next;
		free(data->env->name);
		free(data->env->value);
		free(data->env);
		data->env = temp;
	}
}

void	print_lle(t_data *data)
{
	t_env	*current;

	current = data->env;
	while (current)
	{
		printf("%s", current->name);// pourquoi ca ne simprime pas si linked list imprimer aussi ? verifier coherence printf write
		if (current->value)
			printf("=%s\n", current->value);// pourquoi ca ne simprime pas si linked list imprimer aussi ? verifier coherence printf write
		current = current->next;
	}
}

t_env	*create_lle(char **envp)
{
	int		i = 0;
	t_env	*current = NULL;
	t_env	*head = NULL;
	t_env	*temp = NULL;
	char	*separator;

	while (envp[i])
	{
		current = malloc(sizeof(t_env));
		if (!current)
		{
			free(current);
			return (0);
		}
		separator = ft_strchr(envp[i], '=');
		if (separator)
		{
			current->name = ft_substr(envp[i], 0, separator - envp[i]);
			current->value = ft_strdup(separator + 1);
		}
		else
		{
			current->name = ft_strdup(envp[i]);
			current->value = NULL;
		}
		current->next = NULL;
		if (!current->name || (separator && !current->value))
		{
			free(current->name);
			return (0);
		}
		if (!head)
			head = current;
		else
			temp->next = current;
		temp = current;
		i++;
	}
	return (head);
}

/// @brief 
/// @param data 
/// @param envp 
void	init_env(t_data *data, char **envp)
{
	data->env = create_lle(envp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/26 14:05:13 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 17:13:49 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int exit_code = 0;

char	*get_user_input(const char *prompt)
{
	char	*line;

	line = readline(prompt);
	if (!line)
	{
//		fprintf(stderr, "Error reading line\n");
		return (NULL);
	}
	return (line);
}

t_data	*init_data(t_data *data)
{
	data = malloc(sizeof(t_data));
	if (!data)
	{
		fprintf(stderr, "Error: Memory allocation failed\n");
		return (NULL);
	}
	data->input = NULL;
	data->input = malloc(sizeof(t_input));
	if (!data->input)
	{
		fprintf(stderr, "Error: Memory allocation failed for input\n");
		free(data);
		return (NULL);
	}
	data->input->data = NULL;
	data->env = NULL;
	data->env = malloc(sizeof(t_env));
	if (!data->env)
	{
		perror("init_data, data->env malloc");
		return (NULL);
	}
	data->copy_env = NULL;
	data->stdout_redir = 0;
	data->stdin_redir = 0;
	return (data);
}

t_input	*do_parsing(t_input *head, char **splited_input, t_data *data)
{
	//print_tokens(splited_input);
	head = tokenize(splited_input, data);
	// print_all_token_types(head);
	is_env_var(head, data);
	//print_token_list(head);
	return (head);
}

void	exec_cmd(t_input *head, t_data *data, char *env_path)
{
	t_input	*curr;

	curr = head;
	if (!curr)
		return ;
	exec_pipe(curr, env_path, data);
}

int	main(int ac, char **av, char **envp)
{
	char	*input;
	char	**splited_input;
	char	*env_path;
	t_input	*head;
	t_data	*data;

	(void)ac;
	(void)env_path;
	(void)av;
	init_signals();
	data = NULL;
	data = init_data(data);
	init_env(data, envp);
	while (1)
	{
		data->should_exit = 0;
		input = get_user_input("minishell> ");
		if (!ft_strlen(input))
		{
			restore_terminal();
			init_signals();
		}
		else
		{
			add_history(input);
			splited_input = parse_input(input);
			if (!splited_input)
				continue;
			env_path = get_env_path(envp);
			head = do_parsing(head, splited_input, data);
			data->input = head;
			exec_cmd(head, data, env_path);
			if (data->should_exit)
				break;
			restore_terminal();
			init_signals();
		}
	}
	cleanup_memory(input, splited_input);
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signaux.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 07:36:08 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 16:29:17 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"
#include <termios.h>
// #include <asm-generic/termbits.h>

struct termios g_term_backup;

//SIGINT signal interrupt ctrl + c interrompt/termine le processus courant.
__sighandler_t	handler_sigint(void)
{
	write(1, "\n", 1);
	rl_replace_line("", 0);
	rl_on_new_line();
	return (SIG_IGN);
}


void	handler_sigint2(int sig)
{
	ft_putstr_fd("\n", 1); // Affiche un retour à la ligne
	rl_replace_line("", 0); // Efface la ligne actuelle dans le prompt
	rl_on_new_line(); // Prépare une nouvelle ligne pour l'affichage
	rl_redisplay(); // Réaffiche le prompt
	// rl_replace_line("", 0);
	// rl_on_new_line();
	// rl_redisplay();
	sig++;
	return;
}

void	init_signals(void)
{
	struct termios term;
	
	signal(SIGPIPE, SIG_IGN);//(13, 1)
	// signal(SIGQUIT, SIG_IGN);//ctrl+\ core dump quit proc chil en cours
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, handler_sigint2);
	if (tcgetattr(0, &g_term_backup) == 0)
	{
		term = g_term_backup;
		term.c_lflag &= ~ECHOE;// pour ignorer lecho genre ^/
		// term.c_lflag &= ~ECHOCTL; // pour ignorer l'affichage de ^\ pour SIGQUIT
		tcsetattr(0, 0, &term);// mod attribut term
	}
}

void	restore_terminal(void)
{
	tcsetattr(0, 0, &g_term_backup);
}

/*
| signal      | Définit un gestionnaire de signal      | `void (*)(int)` | Gérer des interruptions               | `SIG_ERR` si échec | `<signal.h>` |
| sigaction   | Modifie l'action associée à un signal  | `int`           | Pour des gestions de signaux avancées | -1 si erreur       | `<signal.h>` |
| sigemptyset | Initialise un ensemble de signaux vide | `int`           | Pour définir un masque de signaux     | -1 si erreur       | `<signal.h>` |
| sigaddset   | Ajoute un signal à un ensemble         | `int`           | Compléter le masque de signaux        | -1 si erreur       | `<signal.h>` |
| tcsetattr   | Modifie les attributs du terminal      | `int`           | Pour configurer le terminal                    | -1 si erreur          | `<termios.h>`                 |
| tcgetattr   | Récupère les attributs du terminal     | `int`           | Pour lire la config actuelle du terminal       | -1 si erreur          | `<termios.h>`                 |
|
 le code que retourne bash dans le cas d'un signal est 128 + le numéro du signal.
				
 					au prompt			en cours dexcution
 
 ctrl + C	  ignore, efface ligne
 
 ctrl + \
 
 ctrl + D

// Gestionnaire de signal pour SIGINT (Ctrl + C)
static void	ft_sigint_handler(int num)
{
	(void)num; // Évite un avertissement pour le paramètre non utilisé

	// Si un processus enfant est en cours d'exécution
	if (g_minishell.signint_child)
	{
		ft_putstr_fd("\n", 1); // Affiche un retour à la ligne
		g_minishell.signint_child = false; // Réinitialise l'indicateur de signal pour le processus enfant
		g_minishell.heredoc_sigint = true; // Indique qu'un SIGINT a été reçu pendant un heredoc
	}
	else
	{
		ft_putstr_fd("\n", 1); // Affiche un retour à la ligne
		rl_replace_line("", 0); // Efface la ligne actuelle dans le prompt
		rl_on_new_line(); // Prépare une nouvelle ligne pour l'affichage
		rl_redisplay(); // Réaffiche le prompt
	}
}

void	ft_sigquit_handler(int num)
{
	(void)num;
	ft_putstr_fd("Quit: 3\n", 1);
}

void	ft_init_signals(void)
{
	struct termios	term;

	term = g_minishell.original_term;
	term.c_lflag &= ~ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
	g_minishell.heredoc_sigint = false;
	g_minishell.signint_child = false;
	signal(SIGINT, ft_sigint_handler);
	signal(SIGQUIT, SIG_IGN);
}

[ ] implementer fonction sleep pour tester les signaux pour interrompre le process
[ ] comprendre le fonctionnement des signaux dans les childs
[ ] comprendre lutilisation des differentes fonctions impliquees
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 17:07:22 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/11 19:10:48 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	cleanup_memory(char *line, char **splited_line)
{
	int	j;

	free(line);
	j = 0;
	while (splited_line[j])
	{
		if (splited_line[j])
			free(splited_line[j]);
		j++;
	}
	free(splited_line);
}

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (i < n && s1[i] && s2[i])
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	if (i < n && (s1[i] || s2[i]))
		return ((unsigned char)s1[i] - (unsigned char)s2[i]);
	return (0);
}

// copie colle avec malloc ET ajoute = a la fin
char	*ft_strdup_equal(const char *src)
{
	int		i;
	int		j;
	int		len;
	char	*dest;

	// if(!src)
		// return();
	i = 0;
	j = 0;
	len = ft_strlen(src);
	dest = (char *)malloc((len + 2) * sizeof(char));
	if (!dest)
		return (NULL);
	dest[j] = '=';
	while (src[i] != 0)
	{
		dest[j] = src[i];
		i++;
		j++;
	}
	dest[++j] = 0;
	return (dest);
}
// export NAME=
// export NAME


// Concatène str dest+src mod moni
// return taille tot
size_t	ft_strcat(char *dest, const char *src)
{
	size_t	src_len;
	size_t	dest_len;
	size_t	i;
	size_t	size;

	src_len = ft_strlen(src);
	dest_len = ft_strlen(dest);
	size = src_len + dest_len;
	i = 0;
	if (size <= dest_len)
		return (src_len + size);
	while (src[i] != 0 && (dest_len + i) < (size - 1))
	{
		dest[dest_len + i] = src[i];
		i++;
	}
	if (size > 0)
		dest[dest_len + i] = 0;
	return (dest_len + src_len);
}

int	ft_strncmp_end(char *s1, char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (i < n && s1[i] && s2[i])
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	if (i < n && (s1[i] || s2[i]))
		return ((unsigned char)s1[i] - (unsigned char)s2[i]);
	return (0);
}

// copie colle avec malloc
char	*ft_strdup(const char *src)
{
	int		i;
	int		len;
	char	*dest;

	i = 0;
	len = ft_strlen(src);
	dest = (char *)malloc((len + 1) * sizeof(char));
	if (!dest)
		return (NULL);
	while (src[i] != 0)
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = 0;
	if (dest == NULL)
	{
		free(dest);
		exit_code = 1;
	}
	return (dest);
}

char	*ft_strndup(const char *src, int n)
{
	int		i;
	int		len;
	char	*dest;

	i = 0;
	len = ft_strlen(src);
	dest = (char *)malloc((len + 1) * sizeof(char));
	if (!dest)
		return (NULL);
	while (i < n)
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = 0;
	if (dest == NULL)
	{
		free(dest);
		exit_code = 1;
	}
	return (dest);
}


char	*ft_equal_strdup(const char *src)
{
	int		i;
	int		len;
	char	*dest;

	i = 0;
	len = ft_strlen(src);
	dest = (char *)malloc((len + 2) * sizeof(char));
	if (!dest)
		return (NULL);
	dest[i] = '=';
	while (src[i] != 0)
	{
		dest[i + 1] = src[i];
		i++;
	}
	dest[i + 1] = 0;
	if (dest == NULL)
	{
		free(dest);
		exit_code = 1;
	}
	return (dest);
}

size_t	ft_strlcpy(char *dest, const char *src, size_t size)
{
	size_t	i;
	size_t	src_len;

	src_len = 0;
	while (src[src_len])
		src_len++;
	if (size == 0)
		return (src_len);
	i = 0;
	while (src[i] && i < size - 1)
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (src_len);
}

t_input	*cat_token(t_input *token, char *value, int len)
{
	t_input	*new_token;
	int		i;
	int		j;
	int		k;

	i = 0;
	j = 0;
	k = 0;
	new_token = malloc(sizeof(t_input));
	if (!new_token)
		return (NULL);
	new_token->token = malloc(sizeof(char) * (len + 1));
	if (!new_token->token)
	{
		free(new_token);
		return (NULL);
	}
	while (token->token[i] && token->token[i] != '$')
	{
		new_token->token[j] = token->token[i];
		i++;
		j++;
	}
	while (value[k])
	{
		new_token->token[j] = value[k];
		k++;
		j++;
	}
	new_token->token[j] = '\0';
	return (new_token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 13:36:38 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/12 19:31:34 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

void wait_all(void)
{
	int status;
	pid_t pid;

	while ((pid = wait(&status)) > 0)
	{
		if (WIFEXITED(status))
			exit_code = WEXITSTATUS(status);
	}
}

int	has_next_cmd(t_input *node)
{
	while (node)
	{
		if (node->type == T_PIPE)
			return (1);
		node = node->next;
	}
	return (0);
}

t_input	*get_next_command(t_input *node)
{
	while (node && node->type != T_PIPE)
		node = node->next;
	if (node && node->type == T_PIPE)
		return (node->next);
	return (NULL);
}

void	child(int prev_pipe, t_input *current, int fd[2], char *env_path, t_data *data)
{

	if (prev_pipe != 0 && !data->stdin_redir)
	{
		dup2(prev_pipe, 0);
		close(prev_pipe);
	}
	if (has_next_cmd(current) && !data->stdout_redir)
	{
		dup2(fd[1], 1);
		close(fd[0]);
		close(fd[1]);
	}
	if (has_redirection(current))
	{
		validate_redirections(current);
		redir(current, data);
	}
	if (fd[1] != -1)
		close(fd[1]);
	if (fd[0] != -1)
		close(fd[0]);
	exec(current, data, env_path);
}

void	parent(int *prev_pipe, t_input **current, int fd[2], t_data **data)
{
	(void)data;

	if (*prev_pipe != 0)
		close(*prev_pipe);
	if (fd[1] != -1)
		close(fd[1]);
	if (fd[0] != -1)
		*prev_pipe = fd[0];
	else
		*prev_pipe = 0;
	*current = get_next_command(*current);
}


void	exec_pipe(t_input *head, char *env_path, t_data *data)
{
	int		fd[2];
	int		prev_pipe;
	pid_t	pid;
	t_input	*current;

	prev_pipe = 0;
	current = head;
	while (current)
	{
		data->stdin_redir = 0;
		data->stdout_redir = 0;
		if (has_next_cmd(current))
			pipe(fd);
		else
		{
			fd[0] = -1;
			fd[1] = -1;
		}
		if (is_builtin(current->token) && is_parent_builtin(current->token) && !prev_pipe && !has_next_cmd(current))
		{
			kind_of_token(data, current);
			current = get_next_command(current);
			continue;
		}
		pid = fork();
		if (pid == 0)
			child(prev_pipe, current, fd, env_path, data);
		else
			parent(&prev_pipe, &current, fd, &data);
	}
	wait_all();
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 13:36:38 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/12 19:30:22 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

char	**build_cmd_arg(t_input *token)
{
	t_input	*tmp;
	int		i;
	char	**cmd;

	i = 1;
	tmp = token->next;
	while (tmp && tmp->type != T_PIPE)
	{
		if (tmp->type != T_OP && (tmp->prev == NULL || tmp->prev->type != T_OP))
			i++;
		tmp = tmp->next;
	}
	cmd = malloc(sizeof(char *) * (i + 1));
	if (!cmd)
		return (NULL);
	cmd[0] = ft_strdup(token->token);
	tmp = token->next;
	i = 1;
	while (tmp && tmp->type != T_PIPE)
	{
		if (tmp->type != T_OP && (tmp->prev == NULL || tmp->prev->type != T_OP))
		{
			cmd[i] = ft_strdup(tmp->token);
			i++;
		}
		tmp = tmp->next;
	}
	cmd[i] = NULL;
	return (cmd);
}



void	exec(t_input *current, t_data *data, char *env_path)
{
	char	**cmd;
	char	*cmd_path;

	if (!current)
		return;
	if (is_builtin(current->token))
	{
		kind_of_token(data, current);
		exit(0);
	}
	cmd = build_cmd_arg(current);
	cmd_path = get_path(env_path, cmd[0]);
	if (!cmd_path)
	{
		ft_printf_stderr("minishell: command not found: %s\n", cmd[0]);
		exit(127);
	}
	execve(cmd_path, cmd, NULL);
	printf("minishell: command not found: %s\n", cmd[0]);
	exit(127);
}

int	count_cmd(t_input *head)
{
	int count = 0;
	t_input *curr = head;

	while (curr)
	{
		if (curr->type == T_CMD || curr->type == T_CMD_ARG)
		{
			count++;
			while (curr && curr->type != T_PIPE)
				curr = curr->next;
		}
		else
			curr = curr->next;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 14:18:44 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/06 16:26:36 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

bool	has_redirection(t_input *current)
{
	while (current)
	{
		if (current->type == T_OP)
			return true;
		current = current->next;
	}
	return false;
}

bool	is_safe_to_exec_in_parent(t_input *current)
{
	t_input *tmp = current;

	if (!tmp)
		return (false);
	while (tmp)
	{
		if (tmp->type == T_PIPE || tmp->type == T_OP)
			return (false);
		tmp = tmp->next;
	}
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 14:38:25 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/12 19:15:18 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

void	redir(t_input *current, t_data *data)
{
	while (current)
	{
		if (current->type == T_OP)
		{
			if (!current->token || !current->next || !current->next->token)
				break ;
			if (!ft_strncmp(current->token, ">>", 3))
				heredoc_append(current, data);
			else if (!ft_strncmp(current->token, "<<", 3))
				heredoc(current);
			else if (!ft_strncmp(current->token, ">", 2)
				|| !ft_strncmp(current->token, "<", 2))
				simple_redir(current, data);
		}
		current = current->next;
	}
}

void	heredoc(t_input *current)
{
	int		hd_pipe[2];
	char	*del;
	char	*line;

	del = current->next->token;
	pipe(hd_pipe);
	while (1)
	{
		line = readline("> ");
		if ((ft_strlen(line) != 0) && ft_strncmp(line, del,
				ft_strlen(line)) == 0)
			break ;
		write(hd_pipe[1], line, ft_strlen(line));
		write(hd_pipe[1], "\n", 1);
		free(line);
	}
	close(hd_pipe[1]);
	dup2(hd_pipe[0], 0);
	close(hd_pipe[0]);
}

void	simple_redir(t_input *current, t_data *data)
{
	int	fd;

	if ((ft_strncmp(current->token, ">", 1) == 0) && current->next)
	{
		fd = open(current->next->token, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		dup2(fd, 1);
		close(fd);
		data->stdout_redir = 1;
	}
	else if ((ft_strncmp(current->token, "<", 1) == 0) && current->next)
	{
		fd = open(current->next->token, O_RDONLY);
		dup2(fd, 0);
		close(fd);
		data->stdin_redir = 1;
	}
}

void	heredoc_append(t_input *current, t_data *data)
{
	int	fd;

	if ((ft_strncmp(current->token, ">>", 2) == 0) && current->next)
	{
		fd = open(current->next->token, O_WRONLY | O_CREAT | O_APPEND, 0644);
		dup2(fd, 1);
		close(fd);
		data->stdout_redir = 1;
	}
	else
		heredoc(current);
}

void	validate_redirections(t_input *current)
{
	int	fd;

	while (current && current->type != T_PIPE)
	{
		if (current->type == T_OP && current->next)
		{
			if (!ft_strncmp(current->token, ">>", 3))
				fd = open(current->next->token, O_WRONLY | O_CREAT | O_APPEND, 0644);
			else if (!ft_strncmp(current->token, ">", 2))
				fd = open(current->next->token, O_WRONLY | O_CREAT | O_TRUNC, 0644);
			else if (!ft_strncmp(current->token, "<", 2))
				fd = open(current->next->token, O_RDONLY);
			else if (!ft_strncmp(current->token, "<<", 3))
			{
				current = current->next;
				continue ;
			}
			if (fd == -1)
			{
				ft_printf_stderr(current->next->token);
				perror(current->next->token);
				exit_code = 1;
				exit(1);
			}
			close(fd);
		}
		current = current->next;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 18:12:43 by lylrandr          #+#    #+#             */
/*   Updated: 2025/04/23 17:14:56 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

int	is_parent_builtin(char *token)
{
	if (!ft_strncmp(token, "cd", 3)
		|| !ft_strncmp(token, "export", 7)
		|| !ft_strncmp(token, "unset", 6)
		|| !ft_strncmp(token, "exit", 5))
		return (1);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/09 20:22:09 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:33:03 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

t_env	*update_env_value(t_env *env, char *env_to_update, char *new_value)
{
	t_env	*current;

	if (!env_to_update || !new_value)
		return (NULL);
	current = search_env_name(env, env_to_update);
	if (!current)
	{
		ft_printf_stderr("cd: %s not set\n", env_to_update);
		exit_code = 1;
		return (NULL);
	}
	free (current->value);
	current->value = ft_strdup(new_value);
	if (!current->value)
		return NULL;
	return (current);
}

void	cd_home(t_data *data)
{
	char *home_value;
	char *new_oldpwd_value;

	home_value = ft_strdup(search_env_value(data->env, "HOME"));
	new_oldpwd_value = ft_strdup(search_env_value(data->env, "PWD"));
	if (chdir(home_value) == -1)
	{
		perror("cd -");
		free (new_oldpwd_value);
		free (home_value);
		exit_code = 1;
		return ;
	}
	update_env_value(data->env, "OLDPWD", new_oldpwd_value);
	update_env_value(data->env, "PWD", home_value);
	free(new_oldpwd_value);
	free(home_value);
}
void	cd_return(t_data *data)
{
	char	*new_pwd_value;
	char	*new_oldpwd_value;

	new_oldpwd_value = getcwd(NULL, 0);
	new_pwd_value = ft_strdup(search_env_value(data->env, "OLDPWD"));
	if (chdir(new_oldpwd_value) == -1)
	{
		perror("cd -");
		free (new_oldpwd_value);
		free (new_pwd_value);
		exit_code = 1;
		return ;
	}
	update_env_value(data->env, "OLDPWD", new_oldpwd_value);
	update_env_value(data->env, "PWD", new_pwd_value);
	free(new_oldpwd_value);
	free(new_pwd_value);
}
void	cd_path(t_data *data)
{
	char	*new_pwd_value;
	char	*new_oldpwd_value;

	new_oldpwd_value = getcwd(NULL, 0);
	if (chdir(data->input->next->token) == -1)
	{
		ft_printf_stderr("bash: cd: %s: ", data->input->next->token);
		perror("");
		free(new_oldpwd_value);
		exit_code = 1;
		return ;
	}
	new_pwd_value = getcwd(NULL, 0);
	update_env_value(data->env, "OLDPWD", new_oldpwd_value);
	update_env_value(data->env, "PWD", new_pwd_value);
	free(new_oldpwd_value);
	free(new_pwd_value);
}


/// @brief built-in change directory `cd <path>`, `cd`, `cd -`, `cd..`
/// @param data Pointer to the shell data structure containing environment variables
/// @param arg Path to change the current working directory to
void b_cd(t_data *data)
{
	t_input		*arg;

	arg = data->input->next;
	if (!arg)
		cd_home(data);
	else if (arg && ft_strncmp_end(arg->token, "-", 1) == 0)
	{
		if (ft_strlen(arg->token)>1)
			ft_printf_stderr("option not needed for minishell\n"); //seulement cd - est géré, pas d'options -*
		else
		{
			cd_return(data);
			b_pwd(data);
		}
	}
	else if (arg && !arg->next)
		cd_path(data);
	else
	{
		ft_printf_stderr("bash: cd: too many arguments\n");
		exit_code = 1;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 15:49:54 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:32:55 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

#define OFF 0
#define ON 1

int n_option(t_input *input)
{
	t_input *current = input->next;
	int found = 0;

	while (current && current->token && current->token[0] == '-' && current->token[1] == 'n')
	{
		int i = 2;
		while (current->token[i] == 'n')
			i++;
		if (current->token[i] != '\0')
			break;
		found = 1;
		current = current->next;
	}
	if (found)
		return ON;
	else
		return OFF;
}

void	b_echo(t_input *cmd)
{
	t_input *current;
	int n_flag = OFF;

	current = cmd->next;
	while (current && current->token && current->token[0] == '-' && current->token[1] == 'n')
	{
		int i = 2;
		while (current->token[i] == 'n')
			i++;
		if (current->token[i] != '\0')
			break;
		n_flag = ON;
		current = current->next;
	}
	while (current && (current->type != T_PIPE && current->type != T_OP)) // ajout de t_op pour ne pas print ">/<"
	{
		ft_printf("%s", current->token);
		if (current->next && current->next->type != T_PIPE)
			ft_printf(" ");
		current = current->next;
	}
	if (n_flag == OFF)
		ft_printf("\n");
	exit_code = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 14:13:15 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:33:22 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

void	b_env(t_data* data)
{
	t_input *current;

	current = data->input;
	while (current->next)
	{
		current = current->next;
		if (ft_strncmp_end(current->token, "env", 3) != 0)
		{
			ft_printf_stderr("env: '%s': No such file or directory\n", current->token);
			return ;
		}
	}
	print_lle(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 09:21:29 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:33:27 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

#define TRUE 1
#define FALSE 0

int str_isdigit(char *str)
{
	int i = 0;

	if (!str || !*str)
		return (0);
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	exit_no_arg()
{
	ft_putstr_fd("exit\n", 1);
	exit(exit_code);
}

void	exit_n(char *num)
{
	int	n;

	n = (ft_atoi(num) % 256 + 256) % 256;
	ft_putstr_fd("exit\n", 1);
	exit_code = n;
	exit(exit_code);
}

void	exit_alpha(char *word)
{
	ft_putstr_fd("exit\n", 1);
	ft_printf_stderr("bash: exit: %s: numeric argument required\n", word);
	exit_code = 2;
	exit(exit_code);
}

void	exit_multiple_arg(void)
{
	ft_printf_stderr("bash: exit: too many arguments\n");
	ft_putstr_fd("exit\n", 1);
	exit_code = 1;
}

void	b_exit(t_data *data)
{
	// exit_code = 0;// est ce vraiment necessaire de mettre a zero ici, plutot dans la boucle dans l'init du main
	if (!data->input->next)// aucun argument
		exit_no_arg();
	else if (data->input->next)
	{
		if (str_isdigit(data->input->next->token) == TRUE && !data->input->next->next)// premier arg numerique, pas de suite
			exit_n(data->input->next->token);
		else if (str_isdigit(data->input->next->token) == TRUE && data->input->next->next)// premier arg numerique, 2eme argument quelquil soit
			exit_multiple_arg();
		else if (str_isdigit(data->input->next->token) == FALSE)
			exit_alpha(data->input->next->token);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 10:34:51 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:33:30 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

void	b_pwd(t_data *data)
{
	char	*pwd_value;

	pwd_value = search_env_value(data->env, "PWD");
	ft_printf("%s\n", pwd_value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 10:35:40 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 19:33:32 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../minishell.h"

void b_unset(t_data *data)
{
	t_input *current;

	if (!data || !data->input)
		return;

	current = data->input->next;
	while (current)
	{
		lle_del_one(&data->env, current->token);
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   core_exec.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 16:02:20 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 18:00:47 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

int	kind_of_token(t_data *data, t_input *input)
{
	char	*input_str;

	input_str = input->token;
	if (ft_strncmp_end(input_str, "echo", 5) == 0)
	{
		b_echo(input);
		return (0);
	}
	if (ft_strncmp_end(input_str, "exit", 5) == 0)
	{
		b_exit(data);
		return (0);
	}
	else if (ft_strncmp_end(input_str, "cd", 3) == 0)
	{
		b_cd(data);
		return (0);
	}
	else if (ft_strncmp_end(input_str, "pwd", 4) == 0)
	{
		b_pwd(data);
		return (0);
	}
	else if (ft_strncmp_end(input_str, "env", 4) == 0)
	{
		b_env(data);
		return (0);
	}
	else if (ft_strncmp_end(input_str, "unset", 6) == 0)
	{
		b_unset(data);
		return (0);
	}
	else if (ft_strncmp_end(input_str, "export", 7) == 0)
	{
		b_export(data);
		return (0);
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expend.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/28 14:51:39 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/09 15:08:45 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	*safe_strjoin_replace(char **dest, const char *suffix)
{
	char	*tmp;
	char	*safe_src;

	if (!suffix)
		return (*dest);
	if (*dest)
		safe_src = ft_strdup(*dest);
	else
		safe_src = ft_strdup("");
	if (!safe_src)
		return (NULL);
	tmp = ft_strjoin(safe_src, suffix);
	free(safe_src);
	if (*dest)
		free(*dest);
	*dest = tmp;
	return (*dest);
}

char	*extract_var_name(const char *str, int *i)
{
	int len = 0;
	char *name;

	while (ft_isalnum(str[*i + len]) || str[*i + len] == '_')
		len++;
	name = ft_substr(str, *i, len);
	*i += len;
	return (name);
}

static void	handle_env_var_expansion(const char *src, int *i, char **result, t_data *data)
{
	char	*tmp;
	char	*var_name;
	char	*var_value;

	(*i)++;
	if (src[*i] == '?')
	{
		(*i)++;
		var_value = ft_strdup("0");  // temporairement 0
		safe_strjoin_replace(result, var_value);
		free(var_value);
		return;
	}
	if (!src[*i] || (!ft_isalnum(src[*i]) && src[*i] != '_'))
	{
		safe_strjoin_replace(result, "$");
		return;
	}
	var_name = extract_var_name(src, i);
	var_value = my_getenv(data, var_name);
	if (!var_value)
		var_value = "";
	tmp = ft_strjoin(*result, var_value);
	free(*result);
	*result = tmp;
	free(var_name);
}


char	*expand_token_string(const char *src, t_data *data)
{
	int		i = 0;
	char	*result;
	char	*tmp;
	char	tmp_str[2];
	char	*old;

	result = ft_calloc(1, sizeof(char));
	if (!result)
		return (NULL);
	while (src[i])
	{
		if (src[i] == '$')
		{
			handle_env_var_expansion(src, &i, &result, data);
			continue;
		}
		else
		{
			tmp_str[0] = src[i];
			tmp_str[1] = '\0';
			tmp = ft_strjoin(result, tmp_str);
			old = result;
			result = tmp;
			free(old);
			i++;
		}
	}
	return (result);
}

void is_env_var(t_input *input, t_data *data)
{
	t_input *curr = input;
	char	*expanded;

	expanded = expand_token_string(curr->token, data);
	free(input->token);
	input->token = expanded;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fonctions_main.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 21:09:38 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/06 16:56:54 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

// Fonction qui imprime le type d'un seul token (comme précédemment)
void	print_token_type(t_input *token)
{
	if (!token)
	{
		printf("Token is NULL\n");
		return ;
	}
	switch (token->type)
	{
	case T_CMD:
		printf("Token type: T_CMD\n");
		break ;
	case T_ARG:
		printf("Token type: T_ARG\n");
		break ;
	case T_FILE:
		printf("Token type: T_FILE\n");
		break ;
		break ;
	case T_OP:
		printf("Token type: T_OP\n");
		break ;
	case T_PIPE:
		printf("Token type: T_PIPE\n");
		break ;
	case T_CMD_ARG:
		printf("Token type: T_CMD_ARG\n");
		break;
	case T_WORD:
		printf("Token type: T_WORD\n");
		break;
	default:
		printf("Unknown token type\n");
		break ;
	}
}

// Fonction pour imprimer tous les types dans une liste chaînée de tokens
void	print_all_token_types(t_input *head)
{
	t_input	*current;

	current = head;
	if (!current)
	{
		printf("No tokens in the list\n");
		return ;
	}
	while (current)
	{
		print_token_type(current); // Affiche le type du token actuel
		current = current->next;   // Passe au token suivant
	}
}

void	print_tokens(char **tokens)
{
	int i = 0;

	printf("Tokens:\n");
	while (tokens[i])
	{
		printf("Token[%d]: %s\n", i, tokens[i]);
		i++;
	}
}

 void	print_token_list(t_input *head)
{
	t_input	*curr = head;
	int		i = 0;

	printf("\n Vérification des tokens après expansion :\n");
	while (curr)
	{
		printf("Token[%d]: %s,(Type: %d)\n", i, curr->token, curr->type);
		curr = curr->next;
		i++;
	}
	printf("\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   more.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 17:52:37 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/12 16:22:03 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_input *filter_args(t_input *args)
{
	t_input *filtered = NULL;
	t_input **tail = &filtered;

	while (args)
	{
		if (args->type == T_OP && args->next)
		{
			args = args->next->next;
			continue;
		}
		if (args->type == T_ARG || args->type == T_WORD)
		{
			*tail = args;
			tail = &args->next;
		}
		args = args->next;
	}
	*tail = NULL;
	return filtered;
}



int	is_cmd(char *token, char **env)
{
	char	*path;
	char	*executable;

	path = get_env_path(env);
	if (!path)
		return (0);
	executable = get_path(path, token);
	free(path);
	if (executable)
	{
		free(executable);
		return (1);
	}
	return (0);
}

int	is_builtin(char *cmd)
{
	if (ft_strncmp(cmd, "echo", 5) == 0)
		return (1);
	if (ft_strncmp(cmd, "cd", 3) == 0)
		return (1);
	else if (ft_strncmp(cmd, "exit", 5) == 0)
		return (1);
	else if (ft_strncmp(cmd, "export", 7) == 0)
		return (1);
	else if (ft_strncmp(cmd, "env", 4) == 0)
		return (1);
	else if (ft_strncmp(cmd, "pwd", 4) == 0)
		return (1);
	else if (ft_strncmp(cmd, "unset", 6) == 0)
		return (1);
	else
		return (0);
}

char	*my_getenv(t_data *data, char *var_name)
{
	while (data->env->next && !(ft_strncmp(data->env->name, var_name, ft_strlen(var_name)) == 0
		&& data->env->name[ft_strlen(var_name)] == '\0'))
		data->env = data->env->next;
	if (ft_strncmp(data->env->name, var_name, ft_strlen(data->env->name)) == 0)
		return (data->env->value);
	else
		return (NULL);
}

bool	in_quotes(char *str, int index)
{
	bool	in_single;
	bool	in_double;
	int		i;

	i = 0;
	in_single = false;
	in_double = false;
	while (i < index && str[i])
	{
		if (str[i] == '\'' && !in_double)
			in_single = !in_single;
		else if (str[i] == '"' && !in_single)
			in_double = !in_double;
		i++;
	}
	return in_double;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing2.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: Invalid date        by                   #+#    #+#             */
/*   Updated: 2025/05/11 20:00:54 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	**second_parsing(char **array)
{
	int		i;
	int		j;
	int		len;
	char	**result;

	if (!array)
		return (NULL);
	i = 0;
	len = 0;
	while (array[i])
	{
		j = 0;
		if (!array[i])
			break;
		if (array[i][0] == '\0')
		{
			i++;
			continue;
		}
		if (array[i][0] == '\'' || array[i][0] == '"')// faudrait pas verifier que i++ existe bien avant dincrementer ?
		{
			len++;
			i++;
			continue ;
		}
		if (!array[i])
			break;
		while (array[i][j])
		{
			if (array[i][j] == ' ')
				len++;
			j++;
		}
		i++;
		len++;
	}
	result = malloc_second_parsing(len);
	if (!result)
		return (NULL);
	return (fill_second_tab(array, result));
}


void	handle_operator(char **tab_token, char **array, int *index, int i)
{
	tab_token[*index] = ft_strdup(array[i]);
	(*index)++;
}

int	handle_non_operator(char **tab_token, char *array, int *index)
{
	char	**split_tab;
	int		j;

	split_tab = ft_split(array, ' ');
	if (!split_tab)
		return (0);
	j = 0;
	while (split_tab[j])
	{
		tab_token[*index] = ft_strdup(split_tab[j]);
		(*index)++;
		j++;
	}
	j = 0;
	while (split_tab[j])
	{
		free(split_tab[j]);
		j++;
	}
	free(split_tab);
	return (1);
}

char	**fill_second_tab(char **array, char **tab_token)
{
	int	i;
	int	index;

	i = 0;
	index = 0;
	while (array[i])
	{
		if (array[i][0] == '\'' || array[i][0] == '"')
			handle_operator(tab_token, array, &index, i);
		else if (array[i][0] == '|' || array[i][0] == '<' || array[i][0] == '>')
			handle_operator(tab_token, array, &index, i);
		else
		{
			if (!handle_non_operator(tab_token, array[i], &index))
				return (NULL);
		}
		i++;
	}
	tab_token[index] = NULL;
	return (tab_token);
}

char	**parse_input(char *input)
{
	char	**first_parse;
	char	**final_parse;

	if (!input)
		return (NULL);
	if (is_open_quotes(input))
	{
		ft_putendl_fd("minishell: syntax error: unclosed quote", 2);
		free(input);
		return (NULL);
	}
	first_parse = first_parsing(input);
	if (!first_parse)
		return (NULL);
	final_parse = second_parsing(first_parse);
	if (!final_parse)
		return (NULL);
	return (final_parse);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/27 14:39:34 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/11 20:03:47 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	**first_parsing(char *input)
{
	int		i;
	int		len;
	char	**array;

	i = 0;
	len = 1;
	while (input[i])
	{
		if (input[i] == '"' || input[i] == '\'')
		{
			len++;
			i = while_quotes(input, i);
		}
		else if (input[i] == '|' || input[i] == '<' || input[i] == '>')
			len++;
		else if (input[i] == ' ' || input[i] == '\t')
		{
			len++;
			while (ft_iswhitespace(input[i]))
				i++;
			i -= 1;
		}
		i++;
	}
	len++;
	array = malloc(sizeof(char *) * (len + 1));
	if (!array)
	{
		perror("first_parsing");
		return (NULL);
	}
	array[len] = NULL;
	return (fill_tab(input, array));
}

int	word_len(char *input)
{
	int		i;
	char	quote;

	i = 0;
	while (input[i] == ' ')
		i++;
	if (input[i] == '\'' || input[i] == '"')
	{
		if (input[i - 1] != ' ' || input[i - 1] != '\t')
			i++;
		quote = input[i];
		i++;
		while (input[i] && input[i] != quote)
			i++;
		if (input[i] == quote)
			i++;
		return (i);
	}
	else
	{
		while (input[i] && input[i] != '|' && input[i] != '>' && input[i] != '<'
			&& input[i] != ' ')
			i++;
		return (i);
	}
}

void	if_operator(char *input, char **array, int *k, int i)
{
	int	j;
	int	len;

	j = 0;
	len = 0;
	while (input[*k + len] == '|' || input[*k + len] == '<' || input[*k
		+ len] == '>')
		len++;
	array[i] = malloc(sizeof(char) * (len + 1));
	if (!array[i])
		return ;
	while (input[*k] == '|' || input[*k] == '<' || input[*k] == '>')
	{
		array[i][j] = input[*k];
		j++;
		(*k)++;
	}
	array[i][j] = '\0';
}

void	if_n_op(char *input, char **array, int *k, int *i)
{
	int		j = 0;
	char	quote;

	while (input[*k] && input[*k] != ' ' && input[*k] != '|' &&
		input[*k] != '<' && input[*k] != '>')
	{
		if (input[*k] == '\'' || input[*k] == '"')
		{
			quote = input[*k];
			(*k)++;
			while (input[*k] && input[*k] != quote)
				array[*i][j++] = input[(*k)++];
			if (input[*k] == quote)
				(*k)++;
		}
		else
		{
			array[*i][j++] = input[(*k)++];
		}
	}
	array[*i][j] = '\0';
}


char	**fill_tab(char *input, char **array)
{
	int	i;
	int	k;
	int	len;

	i = 0;
	k = 0;
	array[i] = NULL;
	while (input[k])
	{
		while (input[k] == ' ')
			k++;
		len = word_len(&input[k]);
		if (input[k] == '\'' || input[k] == '"')
			if_quotes(input, array, &k, &i);
		else if (input[k] == '|' || input[k] == '<' || input[k] == '>')
			if_operator(input, array, &k, i);
		else
		{
			array[i] = malloc(sizeof(char) * (len + 1));
			if (!array[i])
				return (NULL);
			if_n_op(input, array, &k, &i);
		}
		i++;
	}
	// i = 0;
	array[i] = NULL;
	return (array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/27 18:11:17 by lylrandr          #+#    #+#             */
/*   Updated: 2025/04/07 15:35:21 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	**split_path(char *fullpath)
{
	if (!fullpath)
		return (NULL);
	return (ft_split(fullpath, ':'));
}

char	*find_executable(char **path, char *cmd)
{
	int		i;
	char	*temp;
	char	*new_path;

	i = 0;
	if (!path)
		return (NULL);
	while (path[i])
	{
		temp = ft_strjoin(path[i], "/");
		new_path = ft_strjoin(temp, cmd);
		free(temp);
		if (access(new_path, X_OK) == 0)
		{
			//			free_tab(path);
			return (new_path);
		}
		free(new_path);
		i++;
	}
	//	free_tab(path);
	return (NULL);
}

char	*get_path(char *fullpath, char *cmd)
{
	char	**path;

	path = split_path(fullpath);
	return (find_executable(path, cmd));
}

char	*get_env_path(char **env)
{
	int		i;
	char	**path;
	char	*result;

	i = 0;
	while (env[i])
	{
		path = ft_split(env[i], '=');
		if (!path)
			return (NULL);
		if (ft_strncmp_end(path[0], "PATH", 4) == 0)
		{
			result = ft_strdup(path[1]);
			//			free_tab(path);
			return (result);
		}
		//		free_tab(path);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 15:13:05 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/11 18:46:58 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	*handle_quoted_token(char *quoted_str)
{
	int	len;
	int	j;
	int	i;
	char	*result;

	len = ft_strlen(quoted_str);
	result = malloc(sizeof(char) * (len + 1));
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	while (quoted_str[i])
	{
		if (quoted_str[i] == quoted_str[0])
		{
			i++;
			continue;
		}
		result[j++] = quoted_str[i++];
	}
	result[j] = '\0';
	return (result);
}

char	**malloc_second_parsing(int len)
{
	char	**tab_token;

	tab_token = ft_calloc(len + 1, sizeof(char *));
	if (!tab_token)
	{
		perror("malloc_second_parsing");
		return (NULL);
	}
	return (tab_token);
}


void	if_quotes(char *input, char **array, int *k, int *i)
{
	char	quote;
	int		start;
	int		len;
	int		j;

	quote = input[*k];
	start = *k;
	(*k)++;
	while (input[*k] && input[*k] != quote)
		(*k)++;
	if (input[*k] == quote)
		(*k)++;
	else
	{
		printf("missing one quote\n");
		return;
	}
	while (input[*k] && input[*k] != ' ' && input[*k] != '|' && input[*k] != '<'
		&& input[*k] != '>' && input[*k] != ';' && input[*k] != '&'
		&& input[*k] != '(' && input[*k] != ')')
		(*k)++;
	len = *k - start;
	array[*i] = malloc(sizeof(char) * (len + 1));
	if (!array[*i])
		return ;
	j = 0;
	while (j < len)
	{
		array[*i][j] = input[start + j];
		j++;
	}
	array[*i][j] = '\0';
}


//Parcours un token depuis un guillemet jusqu'a la fin du meme type de guillemet puis copie la suite
//jusqu'a un separateur
int	while_quotes(char *input, int i)
{
	if (input[i - 1] != ' ' || input[i - 1] != '\t')
		i++;
	if (input[i] == '\'')
	{
		i++;
		while (input[i] != '\'')
			i++;
	}
	else if (input[i] == '"')
	{
		i++;
		while (input[i] != '"')
			i++;
	}
	while (input[i + 1] != ' ' && input[i + 1] != '|' && input[i + 1] != '<'
		&& input[i + 1] != '>' && input[i + 1])
		i++;
	return (i);
}

int	is_open_quotes(char *input)
{
	int	i;
	int	in_dquote;
	int	in_squote;

	i = 0;
	in_dquote = 0;
	in_squote = 0;
	while (input[i])
	{
		if (input[i] == '"' && !in_squote)
			in_dquote = !in_dquote;
		else if (input[i] == '\'' && !in_dquote)
			in_squote = !in_squote;
		i++;
	}
	if (in_dquote || in_squote)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 14:58:51 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/09 15:50:46 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	parse_and_expand_token(t_input *token, t_data *data)
{
	int		i = 0;
	char	*input = token->token;
	char	*result = ft_calloc(1, sizeof(char));
	char	*temp;
	char	*joined;

	while (input[i])
	{
		if (input[i] == '\'')
			temp = handle_single_quote(input, &i);
		else if (input[i] == '"')
			temp = handle_double_quote(input, &i, data);
		else if (input[i] == '$')
			temp = handle_env_variable(input, &i);
		else
			temp = extract_plain_text(input, &i);
		if (!temp)
			break;
		joined = ft_strjoin(result, temp);
		free(result);

		result = joined;
		free(temp);
	}
	if (!result)
		result = ft_strdup("");
	free(token->token);
	token->token = result;
	if (token->token[0] == '\0')
		token->type = T_SKIP;
	else
		token->type = T_WORD;
}


char *handle_single_quote(char *str, int *i)
{
	int		start;
	int		len;

	start = ++(*i);
	len = 0;
	while (str[*i] && str[*i] != '\'')
	{
		(*i)++;
		len++;
	}
	if (str[*i] == '\'')
		(*i)++;
	return (ft_substr(str, start, len));
}

char	*handle_double_quote(char *str, int *i, t_data *data)
{
	char	*content;
	char	*expanded;
	int		start;
	int		len;

	start = ++(*i);
	len = 0;
	while (str[*i] && str[*i] != '"')
	{
		(*i)++;
		len++;
	}
	content = ft_substr(str, start, len);
	if (str[*i] == '"')
		(*i)++;
	expanded = expand_token_string(content, data);
	free(content);
	return (expanded);
}

char	*handle_env_variable(char *str, int *i)
{
	char	*var_name;
	char	*var_value;

	if (str[*i + 1] == '?')
	{
		*i += 2;
		return ft_itoa(exit_code);
	}
	(*i)++;
	if (!str[*i] || (!ft_isalnum(str[*i]) && str[*i] != '_'))
		return ft_strdup("$");
	var_name = extract_var_name(str, i);
	if (!var_name)
		return ft_strdup("");
	var_value = getenv(var_name);
	free(var_name);
	if (!var_value)
		return ft_strdup("");
	return ft_strdup(var_value);
}

char *extract_plain_text(char *str, int *i)
{
	int start = *i;
	int len = 0;

	while (str[*i] && str[*i] != '\'' && str[*i] != '"' && str[*i] != '$')
	{
		(*i)++;
		len++;
	}
	return ft_substr(str, start, len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/27 13:28:30 by lylrandr          #+#    #+#             */
/*   Updated: 2025/05/11 18:45:30 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_input	*tokenize(char **input, t_data *data)
{
	int		i;
	t_input	*tail;
	t_input	*head;
	t_input	*new_node;
	t_input	*current;

	i = 1;
	tail = malloc(sizeof(t_input));
	if (!tail)
	{
		perror("tokenize");
		exit(1);
	}

	tail->token = ft_strdup(input[0]);
	tail->prev = NULL;
	tail->next = NULL;
	head = tail;
	while (input[i])
	{
		new_node = malloc(sizeof(t_input));
		if (!new_node)
			exit(1);
		new_node->token = ft_strdup(input[i]);
		new_node->prev = tail;
		new_node->next = NULL;
		tail->next = new_node;
		tail = new_node;
		i++;
	}
	current = head;
	while (current)
	{
		current->type = get_token_type(current, current->token, data);
		current = current->next;
	}
	is_cmd_arg(head);
	return (head);
}

t_token_type	get_token_type(t_input *token, char *input, t_data *data)
{
	if (ft_strchr(input, '\'') || ft_strchr(input, '"') || ft_strchr(input,
			'$'))
	{
		parse_and_expand_token(token, data);
		return (token->type);
	}
	if (ft_strncmp(input, "|", 1) == 0)
		return (T_PIPE);
	else if (ft_strncmp(input, "<", 1) == 0 || ft_strncmp(input, ">", 1) == 0
		|| ft_strncmp(input, ">>", 2) == 0 || ft_strncmp(input, "<<", 2) == 0)
		return (T_OP);
	else if (token->prev != NULL && token->prev->type == T_OP)
		return (T_FILE);
	else if (token->prev != NULL && (token->prev->type == T_CMD
			|| token->prev->type == T_ARG || token->prev->type == T_WORD))
		return (T_ARG);
	return (T_CMD);
}

void	is_cmd_arg(t_input *token)
{
	t_input	*curr;

	curr = token;
	while (curr)
	{
		if (curr->type == T_CMD && curr->next && curr->next->type == T_ARG)
			curr->type = T_CMD_ARG;
		curr = curr->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 10:35:45 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/12 16:26:15 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../minishell.h"

int find_equal(char *s)
{
	int i = 0;

	while(s[i])
	{
		if (s[i] == '=')
			return i;
		i++;
	}
	return 0;
}


char	*extract_name(char *env_var)
{
	char	*new_name;
	int		end;

	end = find_equal(env_var);
	new_name = ft_strndup(env_var, end);
	if (!new_name)
		return NULL;
	return (new_name);
}

char	*extract_value(char *env_var)
{
	char	*new_value;
	char	*end;

	end = ft_strchr(env_var, '=');
	new_value = ft_strdup(end + 1);
	if (!new_value)
		return NULL;
	return (new_value);
}

/// @brief builtin affiche, ajoute ou maj environnement
/// @example `export` `export NAME` `export NAME=` `export NAME=value` `export NAME1=value NAME2=value`
/// @param data
void	b_export(t_data *data)
{
	t_input *arg;
	char	*new_name;
	char	*new_value;

	arg = data->input;
	if (!arg->next || arg->next->type == T_PIPE)
		print_export(data);
	else
	{
		while (arg->next)
		{
			// if (arg->next->type == T_SKIP)
			// {
			// 	arg->next = arg->next->next;
			// 	continue ;
			// }
			if (ft_strchr(arg->next->token, '=') == NULL)// pas de '='
				{
					if (is_valid_env_var_syntax(arg->next->token) == TRUE)
						add_env_name(data, arg->next->token);
				}
			else if (is_valid_env_var_syntax(arg->next->token) == TRUE)
			{
				new_value = extract_value(arg->next->token);
				new_name = extract_name(arg->next->token);
				if (search_env_name(data->env, new_name) == NULL) // pas trouve, new value
					add_new_env_var_and_value(data, new_name, new_value);
				else // existe deja
					update_env_value(data->env, new_name, new_value);
			}
			arg->next = arg->next->next;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_T_CMD_ARG.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: monoguei <monoguei@student.lausanne42.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 21:48:31 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/11 20:36:32 by monoguei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../minishell.h"

bool is_valid_env_var_syntax(char *s)
{
	int		i;
	char	c;

	i = 0;
	if (s[i] == '_' || ft_isalpha(s[i]) == TRUE)
	{
		i++;
		while (s[i])
		{
			c = s[i];
			if (c == '_' || ft_isalnum(c) || c == '=')
				i++;
			else
			{
				ft_printf_stderr("bash: export: '%s': not a valid identifier\n", s);
				return (FALSE);
			}
		}
		return (TRUE);
	}
	ft_printf_stderr("bash: export: `%s': not a valid identifier\n", s);
	return (FALSE);
}

void	add_env_name(t_data *data, char *env_name)
{
	t_env	*new_node;

	if (!data || !env_name)
		return;
	if (search_env_name(data->env, env_name) == NULL)// si cette var n'existe pas
	{
		new_node = lle_new(env_name, NULL);
		lle_add_back(&data->env, new_node);
	}
}
void	add_new_env_var_and_value(t_data *data, char *env_name, char *env_value)
{
	t_env	*new_node;

	if (!data || !env_name || !env_value)
		return;
	if (search_env_name(data->env, env_name) == NULL)// si cette var n'existe pas
	{
		new_node = lle_new(env_name, env_value);
		lle_add_back(&data->env, new_node);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_T_CMD.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lylrandr <lylrandr@student.42lausanne.ch>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 21:49:28 by monoguei          #+#    #+#             */
/*   Updated: 2025/05/11 18:16:38 by lylrandr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../minishell.h"

char	*strjoin_name_equal_value(char *name, char *value)
{
	int i = 0;
	int j = 0;
	int tot_len;
	if (value)
		tot_len = ft_strlen(name) + ft_strlen(value) + 4;// = , \0 , " , "
	else
		tot_len = ft_strlen(name) + 1;
	char *s = malloc(sizeof(char) * tot_len);
	if (!s)
		return NULL;
	while (name[i])
	{
		s[i] = name[i];
		i++;
	}
	if (value)
	{
		s[i++] = '=';
		s[i++] = '"';
		while (value[j])
			s[i++] = value[j++];
		s[i++] = '"';
		}
	s[i] = '\0';

	return (s);
}

void lle_to_array(t_data *data)
{
	char	**copy_env;
	t_env	*current;
	int		index_array;

	(void)copy_env;
	index_array = 0;
	current = data->env;
	data->copy_env = malloc(sizeof(char **) * lle_size(current) + 1);
	if (!data->copy_env)
		return ;

	while (current)
	{
		data->copy_env[index_array] = strjoin_name_equal_value(current->name, current->value);
		index_array++;
		current = current->next;
	}
}

void	swap_words(char **a, char **b)
{
	char *temp;
	temp = NULL;

	temp = *a;
	*a = *b;
	*b = temp;
}

int	compare_words(char *w1, char *w2)
{
	int i = 0;

	while (w1[i] && w2[i])
	{
		if (w1[i] < w2[i])
			return 0;
		if (w1[i] > w2[i])
			return 1;
		if  (w1[i] == w2[i])
			i++;
	}
	if (w1[i])
		return 1;
	else
		return 0;
}

void	sort_words(char	**words, int len)
{
	int	i = 0;
	int	j = 1;

	while(i < len && j < len)
	{
		if (compare_words(words[i], words[j]) == 1)
			swap_words(&words[i], &words[j]);
		else
			j++;
		if (j == len)
		{
			i++;
			j = i + 1;
		}
	}
}

void	print_env_array(t_data *data)
{
	int	i;

	i = 0;
	while (i < lle_size(data->env))
	{

		ft_printf("export %s\n", data->copy_env[i]);
		i++;
	}
}

void	free_array(char **array)
{
	int i = 0;

	if (!array)
		return;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

void print_export(t_data *data)
{
	lle_to_array(data);
	sort_words(data->copy_env, lle_size(data->env));
	print_env_array(data);
	free_array(data->copy_env);
}
