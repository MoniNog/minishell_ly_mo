Merci pour ces pr√©cisions ! Je vais maintenant structurer un guide complet avec :

1. **Th√©orie et analogies** pour bien comprendre comment fonctionnent :
   - Les pipes (`|`) en s√©rie
   - Les redirections (`<`, `>`, `>>`) et leurs combinaisons
   - Les here-docs (`<<`), en confirmant si l'expansion est n√©cessaire
   - Les built-ins (`echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`)
   - Le c≈ìur de l'ex√©cution (`execve`) et comment tout relier

2. **Un guide pas √† pas pour chaque fonctionnalit√©**, avec :
   - Une explication d√©taill√©e
   - Un exemple de code minimaliste
   - Des conseils pour √©viter les erreurs et respecter la norme POSIX

3. **Une gestion fid√®le aux erreurs de Bash**, en suivant son comportement (exit codes, `errno`, messages d'erreur, etc.)

Je vais v√©rifier si l'expansion (`<< "EOF"`) est requise pour les here-docs et je te pr√©pare tout √ßa rapidement ! üòä

# Introduction  
Ce guide d√©taill√© explique comment construire pas √† pas un **minishell** (mini-interpr√©teur de commandes fa√ßon Bash) en C, en se concentrant sur les fonctionnalit√©s cl√©s requises : pipelines en s√©rie, redirections d‚Äôentr√©es/sorties (y compris here-documents) et commandes *built-in*. Nous aborderons chaque fonctionnalit√© d‚Äôun point de vue **th√©orique** (avec des analogies simples pour bien comprendre) puis **pratique** (avec une impl√©mentation en C minimaliste conforme aux normes POSIX et au projet Minishell). Nous insisterons √©galement sur la gestion pr√©cise des erreurs pour reproduire fid√®lement le comportement de Bash (codes de sortie, messages d‚Äôerreur via `errno`) et donnerons des conseils d‚Äôoptimisation et de conformit√© (utilisation de `libft`, √©vitement des fuites, etc.). 

Le guide est structur√© selon les grandes √©tapes suivantes¬†:  

1. **Pipelines en s√©rie (`|`)** ‚Äì Ex√©cution de plusieurs commandes reli√©es en pipeline.  
2. **Redirections (`<`, `>`, `>>`)** ‚Äì Redirections d‚Äôentr√©e/sortie, avec combinaisons possibles.  
3. **Here-documents (`<<`)** ‚Äì Lecture d‚Äôinput multi-ligne, avec gestion de l‚Äôexpansion des variables selon le d√©limiteur.  
4. **Built-ins** ‚Äì Impl√©mentation des commandes internes : `echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`.  
5. **C≈ìur de l‚Äôex√©cution (`execve`)** ‚Äì Coordination de tous les √©l√©ments ci-dessus via `fork/execve`, en g√©rant les erreurs et la conformit√© POSIX.  

Chaque section comporte d‚Äôabord une **explication** conceptuelle illustr√©e, puis une **impl√©mentation en C** √©tape par √©tape, avec du code comment√©. 

## 1. Pipelines en s√©rie (`|`)  

### 1.1 Comprendre les *pipes* en s√©rie  
Une *pipeline* relie la sortie standard (**stdout**) d‚Äôune commande √† l‚Äôentr√©e standard (**stdin**) de la suivante. On peut voir cela comme un **tuyau** : la premi√®re commande y d√©verse ses donn√©es (comme de l‚Äôeau) et la seconde les boit en entr√©e. En Bash, l‚Äôop√©rateur `|` sert de connecteur entre les processus. Par exemple, dans `cmd1 | cmd2 | cmd3`, la sortie de `cmd1` est envoy√©e directement comme entr√©e de `cmd2`, et ainsi de suite. On appelle souvent cela un **cha√Ænage de processus**. Gr√¢ce aux pipes, chaque commande peut rester simple (faire une seule t√¢che) et le shell se charge de transmettre le flux de l‚Äôune √† l‚Äôautre.  

**Analogie¬†:** imaginez une cha√Æne de montage o√π chaque ouvrier (processus) prend la production du pr√©c√©dent pour la transformer et la passer au suivant. Les *pipes* jouent le r√¥le du convoyeur entre chaque ouvrier, assurant un flux continu.  

En interne, un pipe est repr√©sent√© par une paire de descripteurs de fichier (un pour l‚Äôextr√©mit√© en lecture, un pour l‚Äôextr√©mit√© en √©criture). √âcrire dans le pipe d‚Äôun c√¥t√© permet de lire ces donn√©es de l‚Äôautre c√¥t√©. Tant que les processus restent connect√©s au pipe, les donn√©es transitent de mani√®re unidirectionnelle (de la sortie de l‚Äôun vers l‚Äôentr√©e de l‚Äôautre).  

**Comportement concurrent¬†:** Toutes les commandes d‚Äôun pipeline doivent s‚Äôex√©cuter **concurremment** (en parall√®le). Contrairement √† l‚Äôex√©cution s√©quentielle avec `;`, le shell ne doit pas attendre qu‚Äôune commande du pipeline se termine pour lancer la suivante ‚Äì elles tournent en m√™me temps. Si on for√ßait une ex√©cution strictement l‚Äôune apr√®s l‚Äôautre, on risquerait des blocages *deadlocks* : par exemple, si `cmd1` produit beaucoup de donn√©es et remplit le buffer du pipe, elle attendrait que `cmd2` les lise, or `cmd2` ne d√©marrerait qu‚Äôapr√®s la fin de `cmd1` ‚Äì blocage assur√©. L‚Äôex√©cution concurrente √©vite cela et correspond au comportement de Bash.  

### 1.2 Impl√©mentation d‚Äôun pipeline en C  
Pour impl√©menter les pipes en C dans Minishell, on utilisera principalement les appels syst√®me **`pipe()`**, **`fork()`**, **`dup2()`** et **`waitpid()`** :  

- **`pipe(int fd[2])`** : cr√©e un tube anonyme et place ses deux descripteurs dans `fd[0]` (lecture) et `fd[1]` (√©criture).  
- **`fork()`** : cr√©e un nouveau processus. Le code s‚Äôex√©cute en double, et on distingue le **processus parent** (retour de fork > 0) et le **processus enfant** (retour = 0). Chaque enfant ex√©cutera une commande du pipeline.  
- **`dup2(oldfd, newfd)`** : redirige un descripteur vers un autre. Ici on l‚Äôemploiera pour brancher l‚Äôentr√©e/sortie standard sur les extr√©mit√©s du pipe (ex. dupliquer le *write-end* du pipe sur STDOUT dans le premier processus, et le *read-end* sur STDIN du second).  
- **`waitpid(pid, ...)`** : permet au parent d‚Äôattendre la fin d‚Äôun processus enfant (et de r√©cup√©rer son code de sortie). On s‚Äôen servira pour attendre **tous** les processus de la pipeline *apr√®s* les avoir lanc√©s, afin de ne redonner la main √† l‚Äôutilisateur qu‚Äôune fois le pipeline termin√©.  

**√âtapes de cr√©ation d‚Äôun pipeline de N commandes¬†:**  

1. **Cr√©er les pipes n√©cessaires** : Pour N commandes, on a besoin de N-1 pipes (chaque pipe relie commande i √† commande i+1). On peut allouer un tableau `int pipes[N-1][2]` et appeler `pipe()` sur chaque √©l√©ment avant de forker les processus.  

2. **Lancer chaque commande avec `fork()`** :  
   - Pour chaque commande *i* (0-index√©) dans le pipeline :  
     - On cr√©e un processus enfant (`pid = fork()`).  
     - Dans l‚Äô**enfant** :  
       - Rediriger les descripteurs :  
         - Si *i > 0* (pas la premi√®re commande), alors cette commande doit recevoir l‚Äôentr√©e du pipe pr√©c√©dent. On fait `dup2(pipes[i-1][0], STDIN_FILENO)` pour brancher l‚Äôentr√©e standard sur le *read-end* du pipe pr√©c√©dent.  
         - Si *i < N-1* (pas la derni√®re commande), alors sa sortie doit aller dans le pipe suivant. On fait `dup2(pipes[i][1], STDOUT_FILENO)` pour envoyer la sortie standard dans le *write-end* du pipe correspondant.  
       - **Fermer tous les descripteurs de pipe** devenus inutiles dans le fils : apr√®s les dup2, on peut fermer *toutes* les extr√©mit√©s de pipe (`close(pipes[j][0])` et `close(pipes[j][1]` pour tous j). Cela √©vite les fuites de FDs dans les enfants.  
       - **Ex√©cuter la commande** : si c‚Äôest une commande externe, construire son chemin et appeler `execve()`. (Pour une *built-in* dans un pipeline, on peut choisir de la traiter comme un externe pour qu‚Äôelle s‚Äôex√©cute dans le fils, voir section built-in.) S‚Äôil y a une erreur √† l‚Äôexec, afficher le message d‚Äôerreur appropri√© et appeler `_exit(code)` pour terminer le processus enfant.  
     - Dans le **parent** :  
       - Ne pas dupliquer dans le parent (sinon on interf√©rerait avec l‚Äôentr√©e/sortie du shell).  
       - Stocker le `pid` de l‚Äôenfant (p.ex. dans un tableau `pids[i]`) pour pouvoir attendre plus tard.  
       - **Ne pas attendre tout de suite** : on continue de cr√©er le pipeline sans attendre chaque commande individuellement. (Attendre ici bloquerait le parent trop t√¥t.)  
   - R√©p√©ter jusqu‚Äô√† la derni√®re commande.  

3. **Fermer les pipes dans le parent** : une fois tous les enfants lanc√©s, le processus parent (le shell) ferme **toutes** les extr√©mit√©s de pipe qu‚Äôil poss√®de encore. En effet, il n‚Äôen a plus besoin (les enfants ont leurs propres copies pour communiquer). Fermer permet aussi aux enfants en lecture de recevoir un EOF quand le processus en √©criture termine.  

4. **Attendre les enfants** : le parent appelle `waitpid` sur chaque PID stock√© pour s‚Äôassurer que tous les processus du pipeline sont termin√©s avant de retourner √† l‚Äôinvite. C‚Äôest √† ce moment qu‚Äôon peut d√©terminer le code de retour du pipeline : par convention POSIX, c‚Äôest le code de sortie de la **derni√®re** commande de la cha√Æne qui est repris dans `$?`. Il faut donc conserver le status du dernier `waitpid` (ou filtrer par pid) et mettre √† jour `$?` avec `WEXITSTATUS(status_last)`. Tous les enfants doivent √™tre *wait*, sinon ils deviendraient des processus zombies.  

En code C, cela peut donner une structure g√©n√©rale comme ci-dessous¬†:

```c
int execute_pipeline(char ***cmds, int cmd_count, char **envp) {
    int pipes[PIPE_MAX][2];                // PIPE_MAX = cmd_count - 1
    pid_t pids[PROCESS_MAX];
    int status = 0;

    // 1. Cr√©er pipes
    for (int i = 0; i < cmd_count - 1; ++i) {
        if (pipe(pipes[i]) < 0) {
            perror("minishell: pipe");
            return 1; // code erreur shell
        }
    }

    // 2. Lancer chaque commande
    for (int i = 0; i < cmd_count; ++i) {
        pids[i] = fork();
        if (pids[i] < 0) {
            perror("minishell: fork");
            return 1;
        }
        if (pids[i] == 0) {  // Enfant
            // Redirections de pipe en entr√©e
            if (i > 0) {
                dup2(pipes[i-1][0], STDIN_FILENO);
            }
            // Redirections de pipe en sortie
            if (i < cmd_count - 1) {
                dup2(pipes[i][1], STDOUT_FILENO);
            }
            // Fermer tous les pipes dans l'enfant
            for (int j = 0; j < cmd_count - 1; ++j) {
                close(pipes[j][0]);
                close(pipes[j][1]);
            }
            // Ex√©cuter la commande (built-in ou externe)
            execve(cmds[i][0], cmds[i], envp);
            // Si on arrive ici, execve a √©chou√©
            fprintf(stderr, "minishell: %s: %s\n", cmds[i][0], strerror(errno));
            _exit((errno == ENOENT) ? 127 : 126);  // 127=commande non trouv√©e, 126=impossible d'ex√©cuter
        }
        // Parent: on ne redirige pas, on continue la boucle
    }

    // 3. Fermer toutes les extr√©mit√©s de pipes dans le parent
    for (int i = 0; i < cmd_count - 1; ++i) {
        close(pipes[i][0]);
        close(pipes[i][1]);
    }

    // 4. Attendre tous les enfants
    int exit_code = 0;
    for (int i = 0; i < cmd_count; ++i) {
        waitpid(pids[i], &status, 0);
        if (i == cmd_count - 1) { 
            // Conserver le code de la derni√®re commande
            if (WIFEXITED(status))
                exit_code = WEXITSTATUS(status);
            else if (WIFSIGNALED(status))
                exit_code = 128 + WTERMSIG(status);  // convention: 128+signal
        }
    }
    return exit_code;
}
```

Dans cet exemple, `cmds` est un tableau de commandes, chaque commande √©tant un tableau de cha√Ænes (le nom de l‚Äôex√©cutable suivi de ses arguments, termin√© par NULL). Le code cr√©e les pipes, duplique les FDs appropri√©s, ex√©cute les commandes, puis attend. On fait attention √† : 

- **Placer les `dup2` juste avant le `execve`** dans l‚Äôenfant, afin que chaque processus n‚Äôait que ses FDs n√©cessaires.  
- **Fermer les descripteurs** de pipe dans tous les processus o√π ils ne servent pas, pour √©viter les bloquants (un `close` dans le parent est crucial pour que l‚Äôenfant lecteur voie l‚ÄôEOF quand le dernier √©crivain se termine).  
- **Ne pas attendre trop t√¥t** : on attend tous ensemble √† la fin, pas apr√®s chaque fork individuel.  

**Conseil d‚Äôoptimisation¬†:** On limite le nombre de forks au strict n√©cessaire : id√©alement, un fork par commande du pipeline. √âvitez de *fork* deux fois pour une m√™me commande (par exemple, ne pas fork dans une fonction d‚Äôexec puis refork ailleurs), sinon vous doublez le nombre de processus sans raison. De m√™me, ne **forkez pas** du tout pour ex√©cuter le pipeline dans le processus parent lui-m√™me (un ‚Äúsubshell‚Äù global) ‚Äì cela complexifie la r√©cup√©ration du code de retour et n‚Äôest pas n√©cessaire ici (on peut tout lancer directement depuis le shell courant en for√ßant l‚Äôattente des enfants ensuite).  

En suivant ces √©tapes, on obtient une ex√©cution pipelin√©e correcte : le shell attend la fin compl√®te de la pipeline avant de redonner la main, et les commandes peuvent tourner en parall√®le.  

## 2. Redirections (`<`, `>`, `>>`)  

### 2.1 Th√©orie des redirections d‚Äôentr√©es/sorties  
Les **redirections** permettent de changer les sources et destinations par d√©faut des donn√©es d‚Äôun programme. Par d√©faut, un processus lit sur l‚Äôentr√©e standard (clavier ou pipe) et √©crit sur la sortie standard (terminal ou pipe). En Bash, avec l‚Äôop√©rateur `<` on peut **remplacer l‚Äôentr√©e standard** d‚Äôune commande par le contenu d‚Äôun fichier, et avec `>` ou `>>` on peut **rediriger la sortie standard** vers un fichier (en √©crasant ou en ajoutant √† la fin). 

- `commande < fichier` : la commande lira les donn√©es du fichier √† la place du clavier. C‚Äôest comme **verser le contenu du fichier dans la commande**. (Analogie¬†: *brancher* un fichier sur l‚Äôentr√©e de la commande, comme si on collait le fichier au lieu de taper au clavier.)  
- `commande > fichier` : la sortie de la commande (ce qu‚Äôelle afficherait √† l‚Äô√©cran) est envoy√©e dans `fichier`. **`>` cr√©e ou √©crase** le fichier. (Analogie¬†: on oriente le flux de sortie vers un seau/fichier au lieu de le laisser couler √† l‚Äô√©cran.)  
- `commande >> fichier` : similaire √† `>`, mais **ajoute √† la fin** du fichier au lieu d‚Äô√©craser. (Analogie¬†: on ajoute de l‚Äôeau au seau sans vider ce qu‚Äôil contient d√©j√†.)  

On peut combiner plusieurs redirections sur une m√™me commande, par exemple : `commande < in.txt >> out.txt`. Cela signifie *‚Äúprends in.txt en entr√©e, ex√©cute la commande, et ajoute la sortie √† out.txt‚Äù*. Bash permet plusieurs redirections sur la m√™me ligne, trait√©es **de gauche √† droite**. Cependant, **chaque descripteur ne peut √™tre redirig√© qu‚Äôune seule fois effectue**. Concr√®tement, rediriger deux fois la sortie standard dans la m√™me commande revient √† ce que **seule la derni√®re redirection s‚Äôapplique** (les pr√©c√©dentes sont quand m√™me √©valu√©es, cr√©ant/tronquant des fichiers, mais elles sont ensuite remplac√©es). Par exemple, `ls >file1 >file2` cr√©era (ou videra) `file1`, puis redirigera finalement la sortie vers `file2` (qui recevra le listing). En g√©n√©ral, en script, on √©vite de rediriger deux fois le m√™me flux, sauf √† utiliser des astuces avec `tee` ou autres.  

### 2.2 Impl√©mentation des redirections en C  
Dans le parsing de Minishell, les symboles `<`, `>` et `>>` seront d√©tect√©s comme des op√©rateurs de redirection suivis d‚Äôun nom de fichier (le *path* cible ou source). L‚Äôimpl√©mentation consiste √† :  

- **Identifier les redirections** pr√©sentes dans la commande (parsing pr√©alable).  
- **Ouvrir les fichiers** correspondants avec les bons modes (lecture ou √©criture, et avec cr√©ation/append selon le cas).  
- **Assigner les descripteurs** de fichiers obtenus √† `STDIN_FILENO` ou `STDOUT_FILENO` au bon moment gr√¢ce √† `dup2()`, afin que l‚Äôex√©cution de la commande lise/√©crive au bon endroit.  
- **G√©rer les erreurs** d‚Äôouverture/duplication en se conformant aux messages d‚Äôerreur Bash et aux codes de retour.  

**Ouverture des fichiers** (`open`) :  

- Pour `< fichier` (redirection d‚Äôentr√©e) : on ouvre le fichier en lecture seule (`O_RDONLY`). Si l‚Äôouverture √©choue (fichier inexistant par ex.), on affichera l‚Äôerreur *‚Äúminishell: fichier: No such file or directory‚Äù* et on ne lancera pas la commande (code de retour 1 ou 127 selon le contexte Bash).  
- Pour `> fichier` (redirection de sortie, √©crasement) : on ouvre le fichier en √©criture avec les flags `O_CREAT | O_TRUNC | O_WRONLY`. `O_CREAT` cr√©e le fichier s‚Äôil n‚Äôexiste pas, `O_TRUNC` le vide s‚Äôil existe. Il faut aussi passer un mode (droits) lors de la cr√©ation, par ex. `0644` (rw-r--r--).  
- Pour `>> fichier` (redirection de sortie en append) : flags `O_CREAT | O_APPEND | O_WRONLY`. S‚Äôil n‚Äôexiste pas, on le cr√©e; s‚Äôil existe on *n‚Äôefface pas*, l‚Äô√©criture se fera √† la fin.  

Chaque `open()` retourne un descripteur de fichier (entier >= 0) en cas de succ√®s, ou -1 en cas d‚Äôerreur (errno est alors positionn√©). Important : si plusieurs redirections de m√™me type s‚Äôencha√Ænent, on peut tr√®s bien ouvrir plusieurs fichiers, mais **seul le dernier sera finalement utilis√©**. On peut impl√©menter cela en stockant le dernier fd ouvert pour l‚Äôentr√©e et la sortie, et en fermant les pr√©c√©dents non utilis√©s imm√©diatement, ou simplement en les rempla√ßant au fur et √† mesure.  

**Duplication vers stdin/stdout** : une fois les fichiers ouverts, juste avant d‚Äôex√©cuter la commande (ou d‚Äôappeler la fonction built-in), on utilise `dup2()` :  

- Si un fichier d‚Äôentr√©e a √©t√© ouvert (redir `<`), on fait `dup2(fd_in, STDIN_FILENO)`. Apr√®s cela, toute lecture via `stdin` (des fonctions comme `read()` ou `get_next_line()` de la commande) lira dans le fichier.  
- Si un fichier de sortie a √©t√© ouvert (redir `>` ou `>>`), on fait `dup2(fd_out, STDOUT_FILENO)`. Toute √©criture vers `stdout` ira dans le fichier.  

On peut ensuite fermer les `fd_in`/`fd_out` d‚Äôorigine, car `dup2` a duplicat√© les FDs vers 0 ou 1.  

**Quand effectuer ces `dup2`¬†?**  
- Si la commande est ex√©cut√©e dans un processus enfant (cas g√©n√©ral, ou dans un pipeline), on fait ces duplications dans l‚Äôenfant avant le `execve`.  
- Si c‚Äôest une commande *built-in* ex√©cut√©e directement dans le processus principal du shell (sans fork, hors pipeline), il faut faire attention : il faut rediriger l‚ÄôIO du shell, ex√©cuter la fonction, puis **restaurer les descripteurs d‚Äôorigine** apr√®s coup (sinon le shell lui-m√™me perd son STDOUT/STDIN normal pour la suite). On peut sauvegarder `int saved_stdin = dup(0)` et `int saved_stdout = dup(1)` avant de rediriger, puis apr√®s ex√©cution de la built-in, restaurer avec `dup2(saved_stdin, 0)` et `dup2(saved_stdout, 1)`.  

**Exemple d‚Äôimpl√©mentation** : Supposons une structure de commande parse contenant deux champs optionnels `infile` et `outfile` (NULL s‚Äôil n‚Äôy en a pas, ou contenant le chemin du fichier, et un flag pour diff√©rencier `>`/`>>` pour outfile). On peut avoir une fonction `setup_redirections(cmd)` qui retourne -1 en cas d‚Äôerreur, 0 en succ√®s :  

```c
int setup_redirections(t_cmd *cmd) {
    int fd;
    // Redirection d‚Äôentr√©e
    if (cmd->infile) {
        fd = open(cmd->infile, O_RDONLY);
        if (fd < 0) {
            fprintf(stderr, "minishell: %s: %s\n", cmd->infile, strerror(errno));
            return -1; // Indique erreur, on ne doit pas exec la commande
        }
        dup2(fd, STDIN_FILENO);
        close(fd);
    }
    // Redirection de sortie
    if (cmd->outfile) {
        int flags = O_CREAT | O_WRONLY;
        if (cmd->append) {            // append mode '>>'
            flags |= O_APPEND;
        } else {                     // overwrite mode '>'
            flags |= O_TRUNC;
        }
        fd = open(cmd->outfile, flags, 0644);
        if (fd < 0) {
            fprintf(stderr, "minishell: %s: %s\n", cmd->outfile, strerror(errno));
            return -1;
        }
        dup2(fd, STDOUT_FILENO);
        close(fd);
    }
    return 0;
}
```

On appellerait cette fonction dans l‚Äôenfant (ou avant l‚Äôappel de la built-in) pour appliquer les redirections. Si une erreur survient, on affichera le message d‚Äôerreur (format√© `minishell: fichier: message`) et on sortira sans ex√©cuter la commande.  

**Gestion des messages d‚Äôerreur** : On utilise `strerror(errno)` pour traduire le code d‚Äôerreur en message lisible (‚ÄúNo such file or directory‚Äù, ‚ÄúPermission denied‚Äù, etc.). Bash inclut le nom de la commande ou du shell en pr√©fixe, par exemple `bash: fichier: error`. Dans notre shell, on peut pr√©fixer par `minishell:` pour indiquer la provenance. Veillez √† bien reproduire les messages d‚Äôerreurs sp√©cifiques :  

- Fichier introuvable en entr√©e : `minishell: fichier: No such file or directory` (errno=ENOENT).  
- Permission refus√©e (par ex essayer d‚Äôouvrir un dossier ou un fichier non autoris√© en √©criture) : `minishell: fichier: Permission denied` (errno=EACCES).  
- S‚Äôil y a une erreur sur plusieurs redirections, Bash affiche seulement la premi√®re rencontr√©e en lisant de gauche √† droite. Par exemple `cat < nofile1 < nofile2` affichera l‚Äôerreur pour `nofile1` puis ne tentera pas `nofile2`. On peut reproduire ce comportement en arr√™tant d√®s la premi√®re erreur rencontr√©e lors du setup des redirections.  

**Combinaisons de redirections** : On peut avoir √† la fois une redirection d‚Äôentr√©e *et* de sortie sur la m√™me commande. L‚Äôordre importe (gauche √† droite) pour l‚Äôouverture, mais finalement on peut ouvrir input puis output (ou vice versa). L‚Äôimportant est de faire tous les `open` **avant** le `execve` ou l‚Äôex√©cution de la commande. Dans l‚Äôexemple ci-dessus, on g√®re `infile` puis `outfile`. Si jamais il y avait plusieurs redir output (ex `cmd > out1 > out2`), notre structure stockerait probablement seulement la derni√®re (`outfile = "out2"`, en ayant ignor√© ou √©cras√© "out1"). Alternativement, on pourrait stocker les deux et appliquer en s√©quence ‚Äì dans ce cas il faudrait ouvrir out1 (ce qui vide/cr√©e le fichier) puis out2 qui prend le dessus. L‚Äôapproche la plus simple est de **remplacer directement** la pr√©c√©dente redirection du m√™me type lors du parsing : ainsi `outfile` ne contiendra que la derni√®re cible utile, ce qui √©vite du travail inutile.  

**Redirections et pipelines** : Il faut conjuguer ces m√©canismes. Lorsqu‚Äôune commande a des redirections et est aussi reli√©e par un pipe, les duplications de descripteurs s‚Äôadditionnent : par exemple, pour une commande du milieu d‚Äôun pipeline ayant `< input.txt`, on devra dupliquer `input.txt` sur STDIN *puis* dupliquer le pipe sortie sur STDOUT. On peut faire `setup_redirections(cmd)` puis faire le `dup2` du pipe pour STDOUT, ou inversement. **Attention** : l‚Äôordre de dup2 importe seulement s‚Äôil y a collision de descripteurs. Pour √™tre s√ªr, on peut d‚Äôabord rediriger les fichiers (ce qui utilise 0 ou 1), puis rediriger les pipes (ce qui r√©√©crase √©ventuellement STDIN/STDOUT). Mais il vaut mieux r√©fl√©chir : si on duplique d‚Äôabord le pipe sur STDOUT puis on duplique un fichier sortie sur STDOUT, le pipe sera perdu. Donc l‚Äôordre doit respecter la commande : *le dernier qui doit prendre effet sur STDOUT doit √™tre fait en dernier*. √âtant donn√© que la s√©mantique Bash est gauche-droite, on peut appliquer dup2 dans cet ordre. Par exemple `cmd < in1 < in2 > out1 >> out2` : Bash va finalement utiliser `in2` et `out2`. On pourrait donc ouvrir in1 (erreur ou pas), puis in2 (prend le relais), puis out1 (ouvre/tronque, mais sera supplant√©), puis out2. Enfin on dup2 in2 sur 0 et out2 sur 1. Pour simplifier, on aura stock√© directement infile = "in2", outfile="out2" avec append=1, et on fait juste ces deux dup2.  

En r√©sum√©, l‚Äôimpl√©mentation doit : analyser et conserver la bonne redirection finale pour chaque flux, ouvrir les fichiers concern√©s avec `open`, effectuer `dup2` pour brancher les flux, et bien g√©rer les erreurs (messages + arr√™ter l‚Äôex√©cution de la commande en erreur). Testez tous les cas (fichier qui existe/pas, droits, combinaisons).  

## 3. Here-documents (`<<`)  

### 3.1 Qu‚Äôest-ce qu‚Äôun here-document ?  
Un **here-document** est un m√©canisme qui permet de fournir √† une commande un *bloc de texte multi-lignes* en entr√©e, directement dans le script, sans passer par un fichier temporaire explicite. En syntaxe shell, on utilise l‚Äôop√©rateur `<<` suivi d‚Äôun **d√©limiteur** (un mot marqueur). Le shell lira ensuite tout ce qui est tap√© **jusqu‚Äô√† rencontrer une ligne contenant uniquement ce d√©limiteur**, et tout ce texte sera fourni √† la commande via son entr√©e standard. Exemple : 

```bash
cat <<EOF
Hello
World
EOF
```  

Ici, la commande `cat` va recevoir deux lignes "Hello" et "World" puis un EOF. Ce bloc de texte entre `<<EOF` et `EOF` s‚Äôappelle un here-document.  

**Analogie¬†:** vous √©crivez une lettre (plusieurs lignes) et vous la confiez √† la commande comme si c‚Äô√©tait un fichier d‚Äôentr√©e. Le d√©limiteur (`EOF` dans l‚Äôexemple) joue le r√¥le de *¬´¬†fin de la lettre¬†¬ª*.  

Quelques d√©tails importants du comportement (h√©rit√©s de Bash)¬†:  

- Le d√©limiteur peut √™tre n‚Äôimporte quel mot. Par convention on utilise souvent `EOF`, mais √ßa pourrait √™tre `FIN`, `STOP` etc. Il doit appara√Ætre seul sur sa ligne de fin pour cl√¥turer le here-doc.  
- **Pas d‚Äôinclusion du d√©limiteur** : les lignes du here-doc *n‚Äôincluent pas* la ligne marquant la fin. Autrement dit, dans l‚Äôexemple, `cat` recevra "Hello\nWorld\n" et pas "EOF".  
- On peut **imbriquer** un here-doc dans une pipeline ou avec d‚Äôautres redirections. Ex: `cmd1 <<EOF | cmd2` est valide (le here-doc fournit l‚Äôentr√©e de cmd1, dont la sortie part en pipe vers cmd2).  

**Expansion des variables** : c‚Äôest un point crucial. Par d√©faut, Bash va effectuer l‚Äôexpansion des variables **dans le contenu du here-document**, exactement comme s‚Äôil s‚Äôagissait d‚Äôun texte d‚Äôentr√©e normal, *sauf* si le d√©limiteur est **entre guillemets** (simples ou doubles). R√®gle : 

- Si le d√©limiteur n‚Äôest pas quoted (pas de guillemets autour), alors **toutes les expansions sont effectu√©es** dans le texte du here-doc (variables `$VAR`, substitution de commande `` `cmd` `` etc.) avant de le donner √† la commande.  
- Si le d√©limiteur est **entre quotes** (par ex `<< "EOF"` ou `<< 'FIN'`), alors **aucune expansion n‚Äôest faite** dans le contenu : on prend le texte tel quel (les `$` restent litt√©raux).  

Cette nuance permet d‚Äôinclure du texte brut comportant des `$` ou autres sans qu‚Äôils soient interpr√©t√©s. Par exemple : 

```bash
VAR=42
cat <<EOF
La valeur est $VAR
EOF
```  
affichera *‚ÄúLa valeur est 42‚Äù* car `$VAR` sera substitu√©. Tandis que : 

```bash
cat << "EOF"
La valeur est $VAR
EOF
```  
affichera litt√©ralement *‚ÄúLa valeur est $VAR‚Äù* (pas d‚Äôexpansion, car le d√©limiteur `"EOF"` est quoted).  

Dans Minishell, il faut impl√©menter ce comportement pour √™tre coh√©rent avec Bash. **Oui, l‚Äôexpansion dans les here-doc est n√©cessaire** (sauf d√©limiteur quotes qui l‚Äôannule). 

### 3.2 Impl√©mentation du here-doc dans Minishell  
**Approche g√©n√©rale** : Lorsqu‚Äôon d√©tecte un token `<< DELIM` dans la ligne de commande, on va devoir :  

1. Lire interactivement (ou depuis l‚Äôinput script) toutes les lignes jusqu‚Äô√† une ligne √©gale au d√©limiteur `DELIM`.  
2. Stocker ces lignes quelque part (en m√©moire ou dans un fichier temporaire).  
3. Fournir ces lignes √† la commande cibl√©e comme entr√©e standard.  

L‚Äôimpl√©mentation typique en C utilise un tube (*pipe*) ou un fichier temporaire pour stocker les donn√©es du here-doc :  

- **Option pipe (courant dans Minishell)** : On cr√©e un `pipe()` d√®s qu‚Äôon rencontre le here-doc. On lit toutes les lignes du here-doc, on les √©crit dans l‚Äôextr√©mit√© en √©criture du pipe, puis on la ferme. Ainsi, l‚Äôextr√©mit√© en lecture du pipe contient tout le texte et pourra √™tre dupliqu√©e sur l‚Äôentr√©e standard de la commande. Cette m√©thode √©vite de cr√©er un fichier sur le disque, tout se fait en m√©moire (via le pipe).  
- Option fichier temporaire : ouvrir un `tmpfile` ou un fichier genre `/tmp/sh-heredoc-xxxxx`, y √©crire les lignes, puis le rouvrir en lecture pour dup sur STDIN. C‚Äôest aussi faisable (Bash utilise en interne un fichier anonyme). Mais dans Minishell on peut se contenter d‚Äôun pipe pour plus de simplicit√©.  

**Lecture du here-doc** : On peut utiliser `readline()` (ou `get_next_line()` si pas de readline) en affichant un prompt sp√©cial (par ex. `> ` comme Bash, ou rien). On lit ligne par ligne : 

- Si la ligne est **NULL** (EOF inattendu, par ex. user a fait `Ctrl+D`), on arr√™te la lecture. Bash dans ce cas affiche un message du type `warning: here-document at line X delimited by end-of-file (wanted 'DELIM')`. On peut g√©rer √ßa en interne (non obligatoire pour le projet, mais possible).  
- √Ä chaque ligne lue, on la compare au d√©limiteur cible : si elle est exactement √©gale (en tenant compte qu‚Äôen g√©n√©ral le d√©limiteur ne doit pas inclure le `\n` final), alors on **stoppe** la collecte (ne pas inclure cette ligne).  
- Sinon, la ligne fait partie du here-doc : on lui ajoute un `\n` (car readline retourne sans le s√©parateur de ligne), puis on l‚Äô√©crit dans le pipe/fichier temporaire. Avant d‚Äô√©crire, on doit √©ventuellement faire l‚Äô**expansion** des variables **si** le d√©limiteur n‚Äô√©tait pas quoted. Pour cela, il faut parcourir la ligne et remplacer les occurrences de `$variable` par leur valeur (utiliser la liste cha√Æn√©e d‚Äôenvironnement, etc.), et `$?` par le code de sortie pr√©c√©dent. On peut r√©utiliser la logique d‚Äôexpansion d√©j√† cod√©e pour l‚Äôanalyse des commandes normales. Si le d√©limiteur √©tait quoted, on n‚Äôeffectue aucune substitution (utiliser un bool√©en `expand` calcul√© lors du parsing : `expand = (delimiter_not_quoted)`).  

Une fois la lecture termin√©e (d√©limiteur trouv√© ou EOF), on ferme l‚Äô√©criture du pipe. √Ä ce stade, l‚Äôextr√©mit√© en lecture du pipe contient tout le texte du here-doc, pr√™t √† √™tre lu.  

**Int√©gration dans l‚Äôex√©cution** : Maintenant, comment l‚Äôutiliser lors de l‚Äôexec ? Si la commande est dans un pipeline ou un fork s√©par√©, il suffit dans le processus enfant (avant execve) de faire `dup2(pipe_read_fd, STDIN_FILENO)` pour que la commande lise dans le pipe. Si la commande n‚Äôest pas fork√©e (built-in dans parent), il faudra dup2 sur STDIN dans le parent, ex√©cuter le built-in, puis restaurer STDIN (m√©canisme similaire aux redirections classiques).  

**Exemple** : `grep "hello" <<EOF > out.txt ... EOF`. On aurait : une redirection here-doc et une redirection de sortie. Concr√®tement :  
- Lire tout le here-doc "EOF" dans un pipe (mettons fd_pipe[0] en lecture, fd_pipe[1] en √©criture).  
- Ouvrir `out.txt` en √©criture (via `open`).  
- Forker le processus pour `grep` (si pipeline). Dans l‚Äôenfant, faire `dup2(fd_pipe[0], STDIN_FILENO)` pour brancher l‚Äôentr√©e sur le here-doc, et `dup2(fd_out, STDOUT_FILENO)` pour la sortie vers fichier. Fermer les fd. Puis `execve("grep", ["grep", "hello", NULL], envp)`.  
- Dans le parent, fermer fd_pipe[0] et fd_pipe[1] apr√®s √©criture du here-doc, fermer fd_out, attendre l‚Äôenfant.  

**Code illustratif** : voici une fonction simplifi√©e qui lit un here-doc (sans le contexte complet du shell) : 

```c
int create_heredoc_pipe(const char *delimiter, int expand, t_env *env, int *heredoc_fd) {
    int pipe_fd[2];
    if (pipe(pipe_fd) < 0) {
        perror("minishell: pipe");
        return -1;
    }
    char *line;
    while (1) {
        line = readline("> ");  // prompt du here-doc
        if (!line) {
            // EOF (Ctrl+D) - stopper
            break;
        }
        if (strcmp(line, delimiter) == 0) {
            free(line);
            break;  // fin du here-doc
        }
        char *expanded_line = line;
        if (expand) {
            expanded_line = expand_variables(line, env);
            // expand_variables: fonction √† impl√©menter s√©par√©ment
        }
        write(pipe_fd[1], expanded_line, strlen(expanded_line));
        write(pipe_fd[1], "\n", 1);
        if (expanded_line != line)
            free(expanded_line);
        free(line);
    }
    close(pipe_fd[1]);      // on ferme l'√©criture, pr√™t √† lire
    *heredoc_fd = pipe_fd[0];
    return 0;
}
``` 

Ici, `expand` est un bool√©en indiquant si on doit faire l‚Äôexpansion (donc si le d√©limiteur n‚Äô√©tait pas entour√© de quotes lors du parsing). `t_env *env` repr√©sente la liste des variables d‚Äôenvironnement (pour chercher les valeurs de `$VAR`). La fonction renvoie le fd de lecture du pipe via `heredoc_fd`. Le `readline("> ")` affiche `>` comme Bash le fait en PS2 prompt pour indiquer une continuation.  

Il faudra appeler `create_heredoc_pipe` au bon moment : typiquement *avant* de forker/exec la commande associ√©e, pour obtenir le fd. En pratique, on peut lors du parsing rep√©rer tous les here-docs pr√©sents dans la ligne (il peut y en avoir plusieurs successifs ou dans des sous-commandes) et les traiter tout de suite pour √©viter d‚Äôavoir √† g√©rer la lecture asynchrone apr√®s un fork (car la gestion du `readline` et des signaux est plus facile dans le processus principal). Par exemple, pour chaque here-doc rencontr√©, on peut g√©n√©rer un fd temporaire et stocker-le dans la structure de la commande comme son `heredoc_fd`. Ensuite, dans l‚Äôex√©cution, si `heredoc_fd` est valide, on fera simplement `dup2(heredoc_fd, STDIN_FILENO)` comme si c‚Äô√©tait un fichier d‚Äôentr√©e normal, puis close.  

**Gestion des signaux** : En mode here-doc interactif, si l‚Äôutilisateur tape `Ctrl+C`, Bash annule le here-doc (on obtient une nouvelle invite normale, et la commande li√©e n‚Äôest pas ex√©cut√©e). Cela implique d‚Äôattraper SIGINT pendant la lecture du here-doc. On peut configurer le handler de SIGINT diff√©remment lorsqu‚Äôon est dans la boucle de here-doc : par exemple, si SIGINT, on ferme le pipe et on retourne une indication d‚Äôabandon. Il y a un certain d√©tail √† impl√©menter, mais mentionnons-le : il faudra peut-√™tre ignorer le reste du here-doc et laisser la commande avort√©e (Bash imprime rien de sp√©cial sauf revenir prompt).  

En r√©sum√©, l‚Äôimpl√©mentation d‚Äôun here-doc dans Minishell consiste √† lire toutes les lignes jusqu‚Äôau d√©limiteur dans un pipe (en respectant la r√®gle d‚Äôexpansion des variables ou non), puis √† rediriger l‚Äôentr√©e standard de la commande vers ce pipe. Pour le projet Minishell, veillez √† bien suivre la sp√©cification : par exemple, le sujet 42 demande souvent de **ne pas √©tendre les variables dans le here-doc si le d√©limiteur est entre guillemets**, ce qu‚Äôon a couvert. Testez avec diff√©rentes valeurs de `$?`, de `$VAR` d√©finies ou non, avec ou sans quotes autour du d√©limiteur.  

## 4. Impl√©mentation des built-ins (`echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`)  

Les *built-ins* sont des commandes **interpr√©t√©es directement par le shell**, sans passer par un ex√©cutable externe. On les impl√©mente donc en C dans notre programme, et on les appelle de mani√®re sp√©cifique lorsqu‚Äôelles sont invoqu√©es. Les built-ins √† coder sont : **`echo`**, **`cd`**, **`pwd`**, **`export`**, **`unset`**, **`env`**, **`exit`**.  

**Pourquoi des built-ins ?** Certaines de ces commandes doivent pouvoir modifier l‚Äô√©tat interne du shell (par ex `cd` change le r√©pertoire courant du processus shell lui-m√™me, `export` modifie les variables d‚Äôenvironnement du shell). On ne peut pas toujours les lancer dans un `execve` s√©par√©, sinon ces modifications seraient perdues une fois le processus child termin√©. C‚Äôest pourquoi le shell les impl√©mente en interne. D‚Äôautres (comme `echo` ou `env`) pourraient techniquement √™tre des externes, mais on les impl√©mente quand m√™me pour √™tre fid√®le au projet ou pour acc√©l√©rer l‚Äôex√©cution.  

En r√®gle g√©n√©rale, on ex√©cutera une built-in **dans le processus parent** shell, sauf si elle fait partie d‚Äôun pipeline. Par exemple, pour `echo` seul, on peut √©viter de fork et juste imprimer; mais pour `echo` dans un pipeline (`echo hello | grep h`), on devra la lancer dans un child comme un externe pour ne pas bloquer le shell (c‚Äôest un choix d‚Äôimpl√©mentation pour coller au comportement concurrent). Un compromis est de toujours forker les pipelines y compris les built-ins, mais de ne pas forker quand une built-in est seule (optimisation).  

Passons en revue chaque built-in avec son comportement et une impl√©mentation minimaliste :  

### 4.1 Built-in `echo`  
**Fonction** : Affiche ses arguments s√©par√©s par des espaces, suivi par un saut de ligne, sur la sortie standard. Supporte l‚Äôoption `-n` pour *ne pas* ajouter de saut de ligne final.  

- Sans option, `echo arg1 arg2` affichera `arg1 arg2` suivi d‚Äôun retour √† la ligne.  
- Avec `-n`, ex: `echo -n "Hello"` affichera `Hello` **sans** retour √† la ligne (le prompt viendra √† la suite sur la m√™me ligne). On peut avoir plusieurs `-n` cons√©cutifs, Bash les traite tous comme l‚Äôoption (tous sauf `-n` sont consid√©r√©s texte √† afficher).  

**Impl√©mentation** : on peut parse `argv` de la fonction echo en C, et d√©tecter l‚Äôoption. Une subtilit√© du projet 42 Minishell : souvent ils demandent de g√©rer uniquement `-n` (pas d‚Äôautres options d‚Äôecho). On consid√©rera donc que toute combinaison commen√ßant par `-n` (exactement `-n` ou `-nnnn`) est une option valide pour ‚Äúpas de newline‚Äù.  

```c
int ft_echo(char * const *args) {
    int newline = 1;
    int i = 1;
    // Traiter les options -n multiples
    while (args[i] && strcmp(args[i], "-n") == 0) {
        newline = 0;
        i++;
    }
    // Afficher tous les arguments restants s√©par√©s par des espaces
    for (; args[i]; ++i) {
        fputs(args[i], stdout);
        if (args[i+1])
            fputc(' ', stdout);
    }
    if (newline)
        fputc('\n', stdout);
    return 0;
}
```  

Ici `args[0]` est "echo", on commence √† i=1. On renvoie 0 comme exit status (echo renvoie toujours 0 sauf cas d‚Äôerreur improbable de write). Pas de message d‚Äôerreur particulier, `echo` ne fait pas d‚Äôerreur en soi (si on ne trouve pas l‚Äôoption on consid√®re que c‚Äôest du texte).  

### 4.2 Built-in `cd` (change directory)  
**Fonction** : Change le r√©pertoire de travail courant du shell. En Bash, `cd` a plusieurs r√®gles :  

- `cd <path>` : change vers le chemin indiqu√© (relatif ou absolu).  
- `cd` sans argument : doit changer vers le **HOME** de l‚Äôutilisateur (variable d‚Äôenv `HOME`). Si `HOME` n‚Äôest pas d√©fini, Bash affiche une erreur : `bash: cd: HOME not set`.  
- `cd -` : option non requise dans le projet minishell (retour au r√©pertoire pr√©c√©dent). Souvent non demand√©, on peut ignorer.  

Notre impl√©mentation utilisera l‚Äôappel syst√®me **`chdir()`** (man 2 chdir) pour effectuer le changement. `chdir(path)` retourne 0 si succ√®s, -1 si erreur (ex : chemin inexistant, pas des droits, etc.). On doit alors g√©rer les erreurs : par ex, si le dossier n‚Äôexiste pas, afficher `minishell: cd: <path>: No such file or directory`. Si c‚Äôest un fichier et pas un dossier : `Not a directory`.  

Aussi, beaucoup de shells mettent √† jour les variables d‚Äôenvironnement `OLDPWD` et `PWD`. Dans Minishell, ce n‚Äôest g√©n√©ralement pas obligatoire de g√©rer `OLDPWD`, mais il faut au moins mettre √† jour `PWD` pour refl√©ter le nouveau r√©pertoire courant (pour que l‚Äôenvironnement soit coh√©rent avec `getcwd`). Facultatif mais conseill√©.  

**Impl√©mentation** :  

```c
int ft_cd(char * const *args, t_env *env) {
    const char *path;
    if (!args[1]) {
        // cd sans argument
        path = getenv("HOME");  // ou utiliser env list
        if (!path) {
            fprintf(stderr, "minishell: cd: HOME not set\n");
            return 1;
        }
    } else {
        path = args[1];
    }
    if (chdir(path) != 0) {
        fprintf(stderr, "minishell: cd: %s: %s\n", path, strerror(errno));
        return 1;
    }
    // M√†j de PWD dans env (facultatif selon projet)
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd))) {
        // update env "PWD" variable
        set_env_value(env, "PWD", cwd);
    }
    return 0;
}
```  

Ici, `t_env *env` serait une structure pour les variables d‚Äôenvironnement. `getenv` peut √™tre utilis√© si on a export√© envp en global, sinon on parcourra la liste. Note : on utilise `strerror(errno)` pour le message d‚Äôerreur. Exemples d‚Äôerreurs : si `path` n‚Äôexiste pas ou est invalide, errno=ENOENT (‚ÄúNo such file or directory‚Äù); si c‚Äôest un fichier, errno=ENOTDIR (‚ÄúNot a directory‚Äù); si pas de droits, EACCES (‚ÄúPermission denied‚Äù).  

On retourne 1 en cas d‚Äôerreur (Bash retourne 1 pour cd failure). Si r√©ussite, retourne 0.  

*N.B.* : Le projet Minishell pr√©cise souvent que `cd` ne doit pas g√©rer `-` (ce n‚Äôest pas demand√©), donc on peut ignorer cette fonctionnalit√©.  

### 4.3 Built-in `pwd` (print working directory)  
**Fonction** : Affiche le chemin absolu du r√©pertoire courant. En C, on peut utiliser `getcwd(NULL, 0)` (ou `getcwd(buf, size)`). 

- Si succ√®s, afficher le chemin suivi d‚Äôun saut de ligne.  
- Si √©chec (rare, par ex. r√©pertoire courant supprim√© ‚Äì cas pathologique), afficher une erreur via `perror("minishell: pwd")` ou un message fixe.  

**Impl√©mentation** :  

```c
int ft_pwd(void) {
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        // getcwd a √©chou√©
        fprintf(stderr, "minishell: pwd: %s\n", strerror(errno));
        return 1;
    }
    printf("%s\n", cwd);
    return 0;
}
```  

Ici on utilise un buffer statique PATH_MAX (d√©fini dans `<limits.h>`). Si on voulait √™tre tr√®s propre, on pourrait allouer dynamiquement en cas de d√©passement, mais ce n‚Äôest pas n√©cessaire dans ce contexte.  

### 4.4 Built-in `export`  
**Fonction** : En Bash, `export` sert √† **marquer des variables d‚Äôenvironnement** pour qu‚Äôelles soient disponibles aux processus enfants, ou √† d√©finir de nouvelles variables. Dans Minishell, on va g√©rer une liste (ou tableau) de variables d‚Äôenvironnement qu‚Äôon transporte.  

Usages :  
- `export` sans argument : afficher l‚Äôensemble des variables d‚Äôenvironnement **tri√©es par ordre alphab√©tique**, dans un format sp√©cifique. Bash affiche avec la syntaxe `declare -x VAR="value"`. Le projet 42 attend g√©n√©ralement cet affichage format√©. Par exemple, `export` seul pourrait afficher:  
  ```  
  declare -x HOME="/home/user"  
  declare -x PATH="/usr/bin:/bin"  
  declare -x VAR1="foo"  
  declare -x VAR2  
  ```  
  (Note : les variables sans valeur sont affich√©es avec juste le nom et pas de `=` ou avec `=""` selon interpr√©tation ‚Äì Bash montre `declare -x VAR2=""` si la variable est pr√©sente mais vide, et `declare -x VAR` sans rien si juste export√© sans valeur *et* pas pr√©sent dans env? Les subtilit√©s de Bash peuvent √™tre complexes, mais l‚Äôimportant est d‚Äôimiter l‚Äôexemple du sujet ou des tests).  
- `export VAR=value` : ajoute ou modifie la variable d‚Äôenvironnement `VAR` avec `value`. Cette variable devient ‚Äúexport√©e‚Äù (disponible aux futurs execve).  
- `export VAR` : sans `=`, Bash cr√©e la variable avec valeur vide si elle n‚Äôexistait pas, ou ne fait rien de plus si elle existe d√©j√†. C‚Äôest quand m√™me consid√©r√© succ√®s (on peut la lister).  
- `export VAR+=value` : (bonus) ajouter √† la valeur existante (concatenation) ‚Äì possiblement hors scope du projet.  
- **Erreurs** : si le nom de variable est invalide (ne commence pas par lettre ou `_`, ou contient des caract√®res non autoris√©s comme `?` ou `+` hors usage sp√©cial), Bash affiche `bash: export: 'X': not a valid identifier` et ne change rien pour cet item, retourne code d‚Äôerreur 1. (Le projet demande de g√©rer ces cas).  

**Impl√©mentation** : Il faut manipuler la structure d‚Äôenvironnement interne. Souvent on la repr√©sente par une liste cha√Æn√©e de structs { name, value, exported_flag }. Dans Minishell, toutes les variables manipul√©es par export/unset/env sont en fait *export√©es* (on peut consid√©rer qu‚Äôon g√®re directement l‚Äôenvironnement du processus). On peut donc utiliser `setenv()` du C, mais pour coller au projet on fera manuellement.  

Plan :  
- Si `args[1]` n‚Äôexiste pas : afficher la liste tri√©e. Pour trier, on peut r√©cup√©rer toutes les var dans un tableau, qsort par name, puis imprimer chaque avec `declare -x NAME="VALUE"` (en mettant des guillemets autour de la valeur et en √©chappant les √©ventuels guillemets sp√©ciaux si besoin).  
- Sinon, pour chaque argument √† partir de 1 :  
  - Valider le format du nom de variable. Cr√©er une fonction `is_valid_identifier(name)` qui check : premier caract√®re alpha ou `_`, suivants alphanum ou `_`. Ne pas autoriser `=` dans le nom (le `=` s√©pare nom/valeur).  
  - D√©couper l‚Äôargument en nom et valeur : rechercher le premier `=` dans la string. Si pr√©sent, s√©parer le nom et la valeur (valeur = cha√Æne apr√®s `=`). Si `=` absent, c‚Äôest un export sans valeur.  
  - Si nom invalide : afficher `minishell: export: 'ARG': not a valid identifier` (bien mettre les quotes autour de l‚Äôargument incrimin√© comme Bash) et marquer un status d‚Äôerreur (on continue √† traiter les autres arguments toutefois).  
  - Si valide : mettre √† jour la liste d‚Äôenvironnement :  
    - Si la variable n‚Äôexiste pas, l‚Äôajouter avec la valeur donn√©e (ou valeur vide si pas de `=`).  
    - Si elle existe d√©j√† : si un `=` est pr√©sent, mettre √† jour la valeur. Si c‚Äôest `VAR+=value`, additionner. (Le cas `+=` est possiblement bonus). Si pas de `=` (juste `export VAR`), on ne modifie pas la valeur existante mais on s‚Äôassure que la variable est marqu√©e export√©e (dans notre shell, par simplicit√©, toute variable dans la liste *est* export√©e de base).  
- Retourner 0 si tous les args sont valides, sinon 1 si au moins un √©tait invalide (Bash retourne 1 s‚Äôil y a eu une erreur sur un identifiant).  

**Code simplifi√©** :  

```c
int is_valid_identifier(const char *name) {
    if (!name || !(*name))
        return 0;
    if (!(ft_isalpha(*name) || *name == '_'))
        return 0;
    for (const char *p = name+1; *p; ++p) {
        if (!(ft_isalnum(*p) || *p == '_'))
            return 0;
    }
    return 1;
}

int ft_export(char * const *args, t_env **env_list) {
    if (!args[1]) {
        // Afficher toutes les variables
        t_env *sorted = sort_env_list(*env_list);
        for (t_env *var = sorted; var; var = var->next) {
            printf("declare -x %s", var->name);
            if (var->value) 
                printf("=\"%s\"", var->value);
            printf("\n");
        }
        free_env_list(sorted);
        return 0;
    }
    int ret = 0;
    for (int i = 1; args[i]; ++i) {
        char *arg = args[i];
        char *eq = strchr(arg, '=');
        char name[BUFFER]; 
        if (eq) {
            size_t namelen = eq - arg;
            ft_strlcpy(name, arg, namelen+1);
        } else {
            ft_strlcpy(name, arg, sizeof(name));
        }
        // Handle + in name (VAR+=)
        int append = 0;
        char *plus = strchr(name, '+');
        if (plus && plus[1] == '\0') {
            append = 1;
            *plus = '\0';
        }
        if (!is_valid_identifier(name)) {
            fprintf(stderr, "minishell: export: '%s': not a valid identifier\n", arg);
            ret = 1;
            continue;
        }
        char *value = NULL;
        if (eq) {
            value = eq + 1;
        }
        // Mettre √† jour env_list
        t_env *var = find_env(*env_list, name);
        if (!var) {
            env_add(env_list, name, value ? value : "");  // ajoute la variable
        } else {
            if (value) {
                if (append)
                    env_set(var, ft_strjoin(var->value, value));
                else
                    env_set(var, value);
            }
            // si pas de value et var existe, ne rien changer
        }
    }
    return ret;
}
```  

Ce code est un peu long (et utilise des fonctions auxiliaires fictives `sort_env_list`, `env_add`, `env_set` etc.), mais d√©crit la logique. L‚Äôessentiel est : valider nom, g√©rer cr√©ation/mise √† jour, afficher erreurs au besoin.  

### 4.5 Built-in `unset`  
**Fonction** : Supprime une ou plusieurs variables d‚Äôenvironnement. Syntaxe : `unset VAR1 VAR2 ...`.  

- Pour chaque nom donn√©, si la variable existe dans la liste d‚Äôenv, on la retire (lib√©rer la m√©moire associ√©e).  
- Si le nom est invalide (m√™mes r√®gles que export pour un identifiant), Bash affiche `bash: unset: 'X': not a valid identifier` ‚Äì on fera de m√™me (`minishell: unset: 'X': not a valid identifier`).  
- Retours : 0 si succ√®s total, 1 si au moins une erreur.  

**Impl√©mentation** :  

```c
int ft_unset(char * const *args, t_env **env_list) {
    int ret = 0;
    for (int i = 1; args[i]; ++i) {
        if (!is_valid_identifier(args[i])) {
            fprintf(stderr, "minishell: unset: '%s': not a valid identifier\n", args[i]);
            ret = 1;
            continue;
        }
        env_remove(env_list, args[i]);  // supprime la variable nomm√©e
    }
    return ret;
}
```  

Ici on r√©utilise `is_valid_identifier`. Attention, Bash consid√®re que `unset` d‚Äôune variable inexistante n‚Äôest pas une erreur ‚Äì on fait juste rien (retour 0 si pas d‚Äôautres soucis). Notre `env_remove` peut simplement ne rien faire si la var n‚Äôest pas trouv√©e.  

### 4.6 Built-in `env`  
**Fonction** : Affiche toutes les variables d‚Äôenvironnement **actuelles** (celles avec une valeur, traditionnellement). Dans Bash, `env` sans argument liste l‚Äôenvironnement complet (chaque ligne `VAR=VALUE`).  

Dans Minishell, on peut l‚Äôimpl√©menter en affichant toutes les variables stock√©es dans notre liste d‚Äôenv *qui ont une valeur*. Par exemple, une variable juste export√©e sans valeur ne devrait peut-√™tre pas s‚Äôafficher (Bash n‚Äôaffiche pas les variables sans valeur dans `env`). On peut choisir de n‚Äôafficher que celles dont `value` n‚Äôest pas vide, ou d√©cider d‚Äôafficher toutes (mais alors comment formater sans valeur ? Possiblement juste ne rien mettre apr√®s `=`). La mani√®re courante : **n‚Äôafficher que les var ayant une valeur non vide** (exactement comme Bash `env` se base sur l‚Äôenvironnement du processus, qui ne contient pas de var sans valeur).  

**Impl√©mentation** :  

```c
int ft_env(t_env *env_list) {
    for (t_env *var = env_list; var; var = var->next) {
        if (var->value) {
            printf("%s=%s\n", var->name, var->value);
        }
    }
    return 0;
}
```  

Ici, on suppose que `env_list` repr√©sente l‚Äôenvironnement *export√©* (donc nos variables et leurs valeurs). Les variables sans valeur (valeur NULL ou cha√Æne vide) on peut les ignorer.  

### 4.7 Built-in `exit`  
**Fonction** : Ferme le shell. En Bash, `exit [n]` permet de quitter avec le code de retour `n` (0 par d√©faut). Dans un shell interactif, Bash affiche `exit` sur la console lorsqu‚Äôon quitte via la commande (pas via Ctrl+D).  

Cas √† g√©rer absolument d‚Äôapr√®s le projet :  
- `exit` sans argument -> quitter avec code 0. (Et probablement afficher `exit` suivi d‚Äôun newline avant de quitter, comme le fait bash interactif).  
- `exit N` avec N un nombre (dans la limite d‚Äôun `long long` √©ventuellement) -> convertir en entier 8-bit (Bash prend le code modulo 256), quitter avec ce code.  
- `exit arg` o√π arg n‚Äôest pas purement num√©rique (par exemple `exit 42abc`) -> Bash affiche une erreur : `bash: exit: 42abc: numeric argument required`, et quitte le shell avec le code **255**. Donc on doit d√©tecter si l‚Äôargument n‚Äôest pas un nombre valide.  
- `exit arg1 arg2` (plus d‚Äôun argument) -> Bash : ne quitte pas ! Il affiche `bash: exit: too many arguments`, retourne code 1, et reste dans le shell (donc on ne fait rien d‚Äôautre). Ce cas est un peu sp√©cial car exit ne exit pas r√©ellement.  

L‚Äôimpl√©mentation doit donc prendre en compte ces conditions.  

**Impl√©mentation** :  

```c
int ft_exit(char * const *args, int interactive) {
    // Si appel√© depuis le processus principal interactif, afficher "exit"
    if (interactive)
        fprintf(stderr, "exit\n");
    // Compter les arguments
    int argc = 0;
    while (args[argc])
        argc++;
    if (argc > 2) {
        // Trop d'arguments
        fprintf(stderr, "minishell: exit: too many arguments\n");
        return 1;  // ne pas quitter, juste code d‚Äôerreur 1
    }
    long exit_code = 0;
    if (argc == 2) {
        // V√©rifier argument num√©rique
        char *endptr = NULL;
        exit_code = strtol(args[1], &endptr, 10);
        if (*endptr != '\0') {
            // Pas enti√®rement num√©rique
            fprintf(stderr, "minishell: exit: %s: numeric argument required\n", args[1]);
            exit(255);
        }
    }
    // Pas d'erreur, on quitte le programme principal
    exit((unsigned char)exit_code);
}
```  

Ici, `interactive` est un bool√©en indiquant si on est dans le shell principal interactif (pour savoir si on doit imprimer "exit"). Dans 42, ils veulent g√©n√©ralement qu‚Äôon imprime "exit" quand on quitte via la commande exit, pour faire comme Bash en mode interactif. On l‚Äôenvoie sur stderr ou stdout ? Bash semble l‚Äôafficher sur stdout. On peut mettre sur stdout aussi.  

L‚Äôutilisation de `strtol` permet de d√©tecter si la cha√Æne n‚Äôest pas purement num√©rique (endptr ne pointant pas sur fin). On g√®re aussi un d√©bordement √©ventuel (strtol g√®re longs, si >LLONG_MAX, endptr peut √™tre positionn√© ou errno=ERANGE). Mais ici √ßa va.  

- Si plus d‚Äôun argument : on affiche l‚Äôerreur et on retourne 1 (sans quitter).  
- Si un argument non num√©rique : message et on `exit(255)` imm√©diatement (Bash quitte dans ce cas).  
- Sinon, on convertit et on exit avec `(unsigned char)exit_code` pour obtenir l‚Äô√©quivalent modulo 256.  

**Important** : Dans le cas o√π `exit` est appel√© dans un *pipeline* ou un *sous-processus* (ex : dans un pipeline ou sous-shell), on ne doit pas quitter le shell principal, juste terminer le processus courant. Dans ce cas, on ne voudra pas appeler `exit()` du programme complet, mais simplement _exit du child avec le code. Donc selon le contexte d‚Äôappel (processus parent principal ou un enfant), l‚Äôeffet diff√®re. Notre `ft_exit` ci-dessus est pr√©vu pour le parent. Si on d√©tecte en amont que la commande est `exit` et que nous sommes dans le processus principal, on peut appeler `ft_exit(args, 1)` pour g√©rer la logique et possiblement terminer. Si c‚Äôest dans un enfant, on peut simplement d√©cider de traiter exit comme un cas normal : par ex, dans l‚Äôenfant, `ft_exit(args,0)` ferait exit du child.  

### 4.8 Int√©gration des built-ins dans le shell  
On peut cr√©er une fonction routeur du style :  

```c
int exec_builtin(char * const *args, t_env **env, int interactive) {
    if (strcmp(args[0], "echo") == 0)
        return ft_echo(args);
    if (strcmp(args[0], "cd") == 0)
        return ft_cd(args, *env);
    if (strcmp(args[0], "pwd") == 0)
        return ft_pwd();
    if (strcmp(args[0], "export") == 0)
        return ft_export(args, env);
    if (strcmp(args[0], "unset") == 0)
        return ft_unset(args, env);
    if (strcmp(args[0], "env") == 0)
        return ft_env(*env);
    if (strcmp(args[0], "exit") == 0) {
        ft_exit(args, interactive);
        // si ft_exit n'a pas termin√© le programme (cas too many args), il a retourn√© 1
        return 1;
    }
    return -1; // not a builtin
}
```  

Cette fonction tente chaque nom de built-in et appelle la fonction correspondante. Si elle renvoie -1, c‚Äôest que ce n‚Äôest pas un built-in et le shell devra tenter un execve externe.  

**Gestion des erreurs built-in** : La plupart des built-ins retournent 1 en cas d‚Äôerreur (ex : mauvais usage, identifiant invalide, etc.), 0 en r√©ussite. On doit assigner ces codes √† `$?`. On a vu quelques messages d‚Äôerreurs sp√©cifiques : `not a valid identifier` pour export/unset, `HOME not set` pour cd, etc., et on les a impl√©ment√©s.  

**Conseil** : Utilisez la libft pour les op√©rations de cha√Æne (ft_strncmp, ft_split, ft_isalpha, etc.), √ßa √©vite de r√©√©crire des fonctions de base et assure la conformit√© du projet (puisque libft est autoris√©e).  

## 5. C≈ìur de l‚Äôex√©cution : coordination avec `execve`  

Nous avons maintenant les briques : pipelines, redirections, here-docs, built-ins. Le c≈ìur de l‚Äôex√©cution de Minishell consiste √† les orchestrer pour chaque ligne de commande entr√©e. Voici le cheminement global lorsque l‚Äôutilisateur entre une commande :  

1. **Parsing** : la ligne est d√©coup√©e en *tokens*, on identifie la structure de la commande : √©ventuellement plusieurs commandes s√©par√©es par `|` (pipeline), des op√©rateurs de redirection `<`, `>`‚Ä¶ On organise souvent cela en une structure de donn√©es (par ex, une liste cha√Æn√©e ou un arbre syntaxique) de commandes avec leurs arguments et meta-info (infile, outfile, heredoc, etc.).  
2. **Ex√©cution** : on distingue plusieurs cas : 
   - Si la ligne comporte **plusieurs commandes pipelin√©es**, on utilisera la logique de pipeline (section 1) pour les ex√©cuter en parall√®le. Chaque commande du pipeline, au moment de son fork/exec, devra appliquer ses **redirections** internes (section 2) et eventuellement son **here-doc** (section 3) sur son entr√©e. 
   - Si la ligne est une **commande simple** (sans pipe) : on v√©rifie si c‚Äôest un **built-in**.  
     - Si oui, on peut l‚Äôex√©cuter *dans le processus courant* (sans fork) pour que ses effets persistent. Mais attention √† appliquer quand m√™me les **redirections** : on peut faire comme dit plus haut, dupliquer les fichiers sur STDIN/STDOUT, ex√©cuter la fonction built-in, puis restaurer. Le code pourrait ressembler √† :  
       ```c
       int saved_stdin = dup(0), saved_stdout = dup(1);
       if (setup_redirections(cmd) == 0) {
           status = exec_builtin(cmd->args, &env, /*interactive=*/1);
       } else {
           status = 1; // redirection error
       }
       // Restore original FDs
       dup2(saved_stdin, 0); close(saved_stdin);
       dup2(saved_stdout, 1); close(saved_stdout);
       ```  
       Ici, `status` est le code de retour du built-in ou 1 si erreur de redirection. On stocke ce status pour `$?`.  
     - Si non (commande externe), on va devoir la lancer via `fork` et `execve`.  
       - On fork un processus enfant. Dans l‚Äôenfant, on applique les redirections (comme dans setup_redirections, y compris here-doc via dup du pipe) puis on appelle `execve()`.  
       - La grande question est : **comment trouver le bon ex√©cutable ?** En effet, si l‚Äôutilisateur tape `ls`, il faut chercher dans les dossiers list√©s par la variable d‚Äôenvironnement PATH (par ex "/bin", "/usr/bin", etc.). Si l‚Äôutilisateur tape un chemin avec `/` (ex `./a.out` ou `/usr/local/bin/python`), alors on essaye directement ce chemin.  
       - Donc, pour une commande externe :  
         - R√©cup√©rer la liste des chemins dans `PATH` (split par `:`).  
         - Si le nom de commande contient un `/` -> on tente `execve(nom, args, envp)`.  
         - Sinon, pour chaque dossier dans PATH, construire un chemin complet `chemin_dossier/commande` et appeler `execve` avec.  
         - Si `execve` r√©ussit, le processus enfant ne revient pas. S‚Äôil √©choue, on r√©cup√®re `errno`. On essaie le suivant si c‚Äô√©tait ENOENT (fichier non trouv√©). Si aucun chemin ne fonctionne, alors la commande n‚Äôexiste pas : on affiche `minishell: commande: command not found` et on exit(127) dans le child.  
         - Si `execve` √©choue pour une raison autre (par ex le fichier existe mais n‚Äôest pas ex√©cutable, ou c‚Äôest un r√©pertoire), on arr√™te tout de suite et on affiche l‚Äôerreur correspondante. Exemples :  
           - Tentative d‚Äôex√©cuter un fichier sans permission d‚Äôexec -> `Permission denied` (code d‚Äôerreur 126 typiquement).  
           - Le fichier est un r√©pertoire -> Bash dit `bash: ./dir: Is a directory` (√©galement code 126).  
           - Pas trouv√© -> message `command not found` (code 127). Bash affiche *‚Äúcommand not found‚Äù* pour les commandes sans slash, mais si on met un chemin inexistant, il affiche *‚ÄúNo such file or directory‚Äù*. Pour reproduire √ßa :  
             - Si le command name contient un `/` (chemin explicite) et execve renvoie ENOENT, on affiche *‚Äúminishell: chemin: No such file or directory‚Äù*.  
             - Si pas de slash (recherche PATH) et rien trouv√©, *‚Äúminishell: commande: command not found‚Äù*.  
         - Ne pas oublier de free la liste des PATH, etc., dans le parent.  
       - Le parent attend le child (`waitpid`) et r√©cup√®re son code.  
   - Si la ligne comporte une **succession de commandes s√©par√©es par `;`** (pas demand√© dans ce projet normalement), on les ex√©cuterait l‚Äôune apr√®s l‚Äôautre. (Minishell 42 n‚Äôexige pas `;` g√©n√©ralement.)  
   - Si la ligne comporte des **op√©rateurs logiques** `&&` ou `||` (pas demand√©s non plus dans Minishell), il faudrait faire en fonction du code de retour pr√©c√©dent.  

Dans le projet courant, on s‚Äôarr√™te aux pipelines et redirections, sans `;` ni `&&`.  

**execve et envp** : L‚Äôappel `execve(path, argv, envp)` n√©cessite un tableau `envp` √† fournir. On doit construire ce tableau √† partir de notre liste cha√Æn√©e d‚Äôenv (export). On ne met que les variables qui ont un `env->value` non NULL (car un envp ne peut pas contenir de variable sans valeur ? en fait si, VAR= existe possible, mais bon). On peut allouer un tableau de char* de la taille de la liste, et remplir avec `name=value` cha√Ænes. C‚Äôest ce `envp` qu‚Äôon passe √† `execve`.  

**Gestion du `errno` et messages** : Une fois `execve` appel√© dans l‚Äôenfant, deux cas :  
- Succ√®s : le code du child ne revient jamais dans notre programme (le binaire externe prend le relais).  
- √âchec : on doit imprimer l‚Äôerreur. *Attention*, on est dans le processus enfant quand on d√©tecte l‚Äô√©chec de `execve` (car on l‚Äôa appel√©). Il faut donc afficher le message d‚Äôerreur **dans l‚Äôenfant**, puis faire `exit(code)` dans l‚Äôenfant, sinon l‚Äôenfant continuera d‚Äôex√©cuter du code du shell (ce qu‚Äôon ne veut pas). Par exemple :  

```c
execve(path, argv, envp);
fprintf(stderr, "minishell: %s: %s\n", argv[0], strerror(errno));
if (errno == ENOENT)
    exit(127);
else 
    exit(126);
```  

On utilise les conventions de codes mentionn√©es (127 not found, 126 permission ou autre erreur d‚Äôexec).  

Le processus parent, lui, se contentera de constater via `waitpid` que le code de sortie de l‚Äôenfant est 126/127 en cas d‚Äôerreur, ou autre. Il n‚Äôaffiche rien de plus (d√©j√† fait dans l‚Äôenfant).  

**Cas particulier** : si la commande est vide (ligne vide ou juste espaces), on ne fait rien (juste r√©afficher prompt). Si la commande est uniquement compos√©e de redirections sans commande derri√®re (ex: `> file` tout seul), Bash consid√®re cela comme une erreur de syntaxe (‚Äúsyntax error near unexpected token‚Äù). Il faut id√©alement d√©tecter ces erreurs de syntaxe lors du parsing et afficher un message du style `minishell: syntax error near unexpected token '>'` et retourner un code d‚Äôerreur 2 (comme Bash). La question ne portait pas sur le parsing syntaxique en d√©tail, mais c‚Äôest un aspect √† ne pas oublier dans un minishell complet.  

### 5.1 Boucle principale et ensemble  
Enfin, le shell aura une boucle principale du type :  

```c
while (1) {
    char *input = readline("minishell$ ");
    if (!input) {
        // Ctrl+D (EOF) 
        break;
    }
    if (*input == '\0') {
        free(input);
        continue;
    }
    add_history(input);
    // Parser la ligne en structure de commandes (pipeline)
    t_pipeline *pipeline = parse_input(input);
    free(input);
    if (!pipeline) {
        // erreur de parsing (ex: quotes non ferm√©es), on peut afficher une erreur et continue
        g_exit_status = 2;
        continue;
    }
    // Ex√©cuter le pipeline
    int exit_code = execute_pipeline_structure(pipeline, &env);
    g_exit_status = exit_code;
    free_pipeline(pipeline);
}
```

Ici `g_exit_status` est une variable globale qui suit `$?`. On utilise `readline` pour obtenir l‚Äôinput (librairie GNU Readline permise dans le projet), ce qui g√®re aussi l‚Äôhistorique etc. 

La fonction `execute_pipeline_structure` orchestrerait selon les cas : pipeline multiple ou commande simple, en appelant les fonctions qu‚Äôon a construites. 

**Conformit√© POSIX & 42** :  
- Utiliser uniquement les appels syst√®mes autoris√©s (pas de `system()` √©videmment, ni de execvp ‚Äì on a `execve`).  
- G√©rer correctement les signaux (SIGINT, SIGQUIT) pour qu‚Äôils se comportent comme dans Bash (ex: Ctrl+C affiche un prompt nouveau sur ligne suivante sans quitter le shell, Ctrl+\ ne fait rien visible, etc., tandis que dans un child process il faut r√©tablir le comportement par d√©faut ou ignorer selon consignes). Cela implique √©ventuellement de jouer avec `signal()` ou `sigaction()` avant de fork/exec.  
- Pas de fuite de m√©moire : chaque allocation (ex: args via parsing, structure pipeline) doit √™tre lib√©r√©e une fois plus utilis√©e. Pareil pour les descripteurs de fichier : assurez-vous qu‚Äôils sont ferm√©s (sauf 0,1,2 bien s√ªr) une fois inutiles, pour ne pas perdre des FD √† chaque ex√©cution.  
- Norme de codage 42 : fonctions de moins de 25 lignes, etc. On doit donc d√©couper en plusieurs fonctions utilitaires. Par exemple, la gestion d‚Äôun pipeline peut √™tre r√©partie entre une fonction qui cr√©e les pipes, une fonction qui fork chaque commande, etc.  

**Conseils d‚Äôoptimisation** :  
- √âvitez les duplications de code : par exemple, utilisez une fonction commune pour appliquer les redirections (input, output, heredoc) aussi bien pour une simple commande que pour chaque segment d‚Äôun pipeline.  
- Minimalisme : n‚Äôallouez pas inutilement. Par exemple, pour parcourir PATH, on peut `strdup` chaque chemin, ajouter `"/cmd"` et tester, puis free imm√©diatement. Pas besoin de stocker tous les chemins dans un tableau si on peut les tester un par un.  
- **Pr√©venir les leaks** : chaque `malloc` doit avoir un `free` correspondant, m√™me en cas d‚Äôerreur (un bon moyen est d‚Äôavoir des fonctions de nettoyage du contexte qui sont appel√©es avant de retourner en cas d‚Äôerreur). Utilisez valgrind pour traquer les leaks une fois votre shell en √©tat de marche.  
- **Erreurs fatales** : en cas d‚Äôerreur critique (ex: `pipe()` ou `fork()` qui √©choue, par manque de ressources), il est acceptable de afficher un message et √©ventuellement quitter le shell. Ces cas sont rares, mais ne pas ignorer la valeur de retour de ces appels.  
- **Structures de donn√©es** : optez pour des structures simples. Par exemple, une liste cha√Æn√©e de commandes pour un pipeline, o√π chaque n≈ìud contient ses args (tableau de char*), les infos de redir (infile, outfile, delimiter heredoc, etc.), et pointeur vers suivant. C‚Äôest suffisant. Un arbre n‚Äôest pas forc√©ment n√©cessaire dans un minishell sans `&&` ni `;`.  

En suivant ce guide, vous devriez obtenir un minishell fonctionnel qui g√®re correctement les pipes en s√©rie, les redirections (y compris multiples), les here-documents avec expansions appropri√©es, les commandes built-in et l‚Äôex√©cution de programmes externes via `execve`. √Ä chaque √©tape, comparez le comportement avec Bash pour vous assurer de la conformit√© (messages d‚Äôerreur, retours, etc.), car le diable est dans les d√©tails en programmation de shell. Bon codage !

